Index: src/libmm3d/md3filter.h
===================================================================
--- src/libmm3d/md3filter.h	(revision 440)
+++ src/libmm3d/md3filter.h	(working copy)
@@ -28,6 +28,18 @@
 #ifndef __MD3FILTER_H
 #define __MD3FILTER_H
 
+#define TURTLE_ARENA // Enable special tag support for Turtle Arena, that should not be in mm3d
+
+//#define MDR_LOAD // Unfinished
+#define MDR_EXPORT // Unfinished
+
+#if defined MDR_LOAD || defined MDR_EXPORT
+#define MDR_GENERAL // Stuff for load and export
+#define MDR_VERSION	2
+#endif
+
+
+
 #define MD3_VERSION 15
 #define MAX_QPATH 64
 #define MD3_MAX_FRAMES 1024
@@ -73,6 +85,16 @@
 
    protected:
 
+#ifdef MDR_GENERAL
+      typedef enum _MeshType_e
+      {
+         MT_None,
+         MT_MD3,
+         MT_MDR,
+         MT_MAX
+      } MeshTypeE;
+#endif
+
       typedef enum _MeshSection_e
       {
          MS_None = -1,
@@ -100,18 +122,27 @@
 
       typedef struct _Md3FileData_t
       {
+#ifdef MDR_GENERAL
+         MeshTypeE type; // MD3 or MDR
+#endif
          MeshSectionE section;
          string modelBaseName;
          string modelFile;
          string tag;
          int32_t tagPoint;
          DataSource * src;
-         int32_t offsetMeshes;
-         int32_t numMeshes;
+         int32_t offsetMeshes; // MD3 only
+         int32_t numMeshes; // MD3 only
          int32_t offsetTags;
          int32_t numTags;
          int32_t numFrames;
-         MeshVectorInfoT ** meshVecInfos;
+         MeshVectorInfoT ** meshVecInfos; // MD3 only
+#ifdef MDR_GENERAL
+         // Only used by MDR
+         int32_t numBones;
+         int32_t numLODs;
+         int32_t offsetLODs;
+#endif
       } Md3FileDataT;
       typedef std::list< Md3FileDataT > Md3FileDataList;
 
@@ -141,9 +172,12 @@
       // Indicates if the animation specified is contained in the 
       // specified MD3 model section 
       bool     animInSection( std::string animName, MeshSectionE section );
-      bool     groupInSection( std::string animName, MeshSectionE section );
-      bool     tagInSection( std::string animName, MeshSectionE section );
-      bool     tagIsSectionRoot( std::string animName, MeshSectionE section );
+      bool     groupInSection( std::string groupName, MeshSectionE section );
+#ifdef MDR_EXPORT
+      bool boneJointInSection( std::string jointName, MeshSectionE section );
+#endif
+      bool     tagInSection( std::string tagName, MeshSectionE section );
+      bool     tagIsSectionRoot( std::string tagName, MeshSectionE section );
 
       // Path handling functions
       std::string extractPath( const char * md3DataPath );
@@ -151,6 +185,11 @@
       std::string sectionToPath( int materialIndex );
       std::string defaultPath();
 
+#ifdef MDR_GENERAL
+      bool isMdr(const char *filename);
+      Model::AnimationModeE animMode(Md3Filter::MeshTypeE type);
+#endif
+
       Model      * m_model;
       DataSource * m_src;
       //      int32_t   ** meshVecIds;
@@ -162,19 +201,26 @@
       int              m_idleFrame;
       std::string      m_lastMd3Path;
       Md3PathList      m_pathList;
+      Model::AnimationModeE m_animationMode;
 
       //writes
+#ifdef MDR_EXPORT
+      Model::ModelErrorE writeSectionFile( const char * filename, Md3Filter::MeshTypeE type,
+            Md3Filter::MeshSectionE section, MeshList & meshes );
+#else
       Model::ModelErrorE writeSectionFile( const char * filename, MeshSectionE section, MeshList & meshes );
+#endif
       bool     writeAnimations();
       size_t   writeIdentity();
       DataDest * m_dst;
 
       //writes util
+      bool animSyncWarning(std::string name);
       bool     getVertexNormal(Model * model, int groupId, int vertexId, float *normal);
       double   greater(double a, double b);
       double   smaller(double a, double b);
       Matrix   getMatrixFromPoint( int anim, int frame, int point );
-      void getExportAnimData( int fileAnim, int & modelAnim, 
+      bool getExportAnimData( int modelAnim,
             int & fileFrame, int & frameCount, int & fps );
 
 };
Index: src/libmm3d/model.cc
===================================================================
--- src/libmm3d/model.cc	(revision 440)
+++ src/libmm3d/model.cc	(working copy)
@@ -264,7 +264,6 @@
      m_validJoints( false ),
      m_forceAddOrDelete( false ),
      m_animationMode( ANIMMODE_NONE ),
-     m_animationLoop( true ),
      m_currentFrame( 0 ),
      m_currentAnim( 0 ),
      m_currentTime( 0.0 )
Index: src/libmm3d/mm3dfilter.cc
===================================================================
--- src/libmm3d/mm3dfilter.cc	(revision 440)
+++ src/libmm3d/mm3dfilter.cc	(working copy)
@@ -345,6 +345,16 @@
    MF_MAT_CLAMP_T = 32
 } MisfitFlagsE;
 
+typedef enum _MisfitFrameAnimFlags_e
+{
+   MFAF_ANIM_LOOP = 0x0001
+} MisfitFrameAnimFlagsE;
+
+typedef enum _MisfitSkelAnimFlags_e
+{
+   MSAF_ANIM_LOOP = 0x0001
+} MisfitSkelAnimFlagsE;
+
 static const uint16_t _misfitOffsetTypes[MDT_MAX]  = {
 
    // Offset A types
@@ -1789,6 +1799,7 @@
          unsigned anim = model->addAnimation( Model::ANIMMODE_SKELETAL, name );
          model->setAnimFPS( Model::ANIMMODE_SKELETAL, anim, fps );
          model->setAnimFrameCount( Model::ANIMMODE_SKELETAL, anim, frameCount );
+         model->setAnimationLooping(Model::ANIMMODE_SKELETAL, anim, (flags & MSAF_ANIM_LOOP));
 
          for ( unsigned f = 0; f < frameCount; f++ )
          {
@@ -1874,6 +1885,7 @@
          unsigned anim = model->addAnimation( Model::ANIMMODE_FRAME, name );
          model->setAnimFPS( Model::ANIMMODE_FRAME, anim, fps );
          model->setAnimFrameCount( Model::ANIMMODE_FRAME, anim, frameCount );
+         model->setAnimationLooping(Model::ANIMMODE_FRAME, anim, (flags & MFAF_ANIM_LOOP));
 
          for ( unsigned f = 0; f < frameCount; f++ )
          {
@@ -2970,6 +2982,11 @@
          uint16_t  flags = 0x0000;
          float32_t fps = sa->m_fps;
 
+         if (sa->m_animationLoop)
+         {
+            flags |= MSAF_ANIM_LOOP;
+         }
+
          animSize = animSize;
          m_dst->write( animSize );
          m_dst->write( flags );
@@ -3052,6 +3069,11 @@
          uint16_t  flags = 0x0000;
          float32_t fps = fa->m_fps;
 
+         if (fa->m_animationLoop)
+         {
+            flags |= MFAF_ANIM_LOOP;
+         }
+
          m_dst->write( animSize );
          m_dst->write( flags );
          m_dst->writeBytes( (const uint8_t *) fa->m_name.c_str(), fa->m_name.length() + 1 );
Index: src/libmm3d/model_anim.cc
===================================================================
--- src/libmm3d/model_anim.cc	(revision 440)
+++ src/libmm3d/model_anim.cc	(working copy)
@@ -50,6 +50,7 @@
                anim->m_name = name;
                anim->m_fps  = 30.0;
                anim->m_spf  = (1.0 / anim->m_fps);
+               anim->m_animationLoop = true;
                anim->m_frameCount = 1;
                anim->m_validNormals = false;
 
@@ -73,6 +74,7 @@
                FrameAnim * anim = FrameAnim::get();
                anim->m_name = name;
                anim->m_fps = 10.0;
+               anim->m_animationLoop = true;
                anim->m_validNormals = false;
 
                MU_AddAnimation * undo = new MU_AddAnimation();
@@ -914,6 +916,7 @@
             if ( num >= 0 )
             {
                setAnimFrameCount( ANIMMODE_FRAME, num, frameCount );
+               setAnimationLooping( ANIMMODE_FRAME, num, isAnimationLooping( ANIMMODE_SKELETAL, anim ) );
 
                if ( frameCount > 0 )
                {
@@ -1694,7 +1697,7 @@
          double totalTime = spf * m_frameAnims[m_currentAnim]->m_frameData.size();
          while ( frameTime >= totalTime )
          {
-            if ( !m_animationLoop )
+            if ( !m_frameAnims[m_currentAnim]->m_animationLoop )
             {
                return false;
             }
@@ -1723,7 +1726,7 @@
          double totalTime = sa->m_spf * sa->m_frameCount;
          while ( frameTime > totalTime )
          {
-            if ( !m_animationLoop )
+            if ( !sa->m_animationLoop )
             {
                return false;
             }
@@ -1741,7 +1744,7 @@
       {
          Matrix transform;
          interpSkelAnimKeyframeTime( m_currentAnim, frameTime,
-               m_animationLoop, j, transform );
+               sa->m_animationLoop, j, transform );
 
          Matrix relativeFinal( m_joints[j]->m_relative );
          relativeFinal = transform * relativeFinal;
@@ -2039,14 +2042,57 @@
    return m_currentTime;
 }
 
-void Model::setAnimationLooping( bool o )
+void Model::setAnimationLooping( AnimationModeE mode, unsigned anim, bool loop )
 {
-   m_animationLoop = o;
+   switch ( mode )
+   {
+      case ANIMMODE_SKELETAL:
+         if ( anim < m_skelAnims.size() )
+         {
+            MU_SetAnimLoop * undo = new MU_SetAnimLoop();
+            undo->setAnimLoop( mode, anim, loop, m_skelAnims[anim]->m_animationLoop );
+            sendUndo( undo );
+
+            m_skelAnims[anim]->m_animationLoop = loop;
+         }
+         break;
+      case ANIMMODE_FRAME:
+         if ( anim < m_frameAnims.size() )
+         {
+            MU_SetAnimLoop * undo = new MU_SetAnimLoop();
+            undo->setAnimLoop( mode, anim, loop, m_frameAnims[anim]->m_animationLoop );
+            sendUndo( undo );
+
+            m_frameAnims[anim]->m_animationLoop = loop;
+         }
+         break;
+      default:
+         break;
+   }
 }
 
-bool Model::isAnimationLooping() const
+bool Model::isAnimationLooping( AnimationModeE mode, unsigned anim ) const
 {
-   return m_animationLoop;
+   switch ( mode )
+   {
+      case ANIMMODE_SKELETAL:
+         if ( anim < m_skelAnims.size() )
+         {
+            return m_skelAnims[anim]->m_animationLoop;
+         }
+         break;
+      case ANIMMODE_FRAME:
+         if ( anim < m_frameAnims.size() )
+         {
+            return m_frameAnims[anim]->m_animationLoop;
+         }
+         break;
+      default:
+         break;
+   }
+
+   // shouldn't happen
+   return true;
 }
 
 void Model::setNoAnimation()
Index: src/libmm3d/md3filter.cc
===================================================================
--- src/libmm3d/md3filter.cc	(revision 440)
+++ src/libmm3d/md3filter.cc	(working copy)
@@ -63,9 +63,16 @@
 
 const int MD3_ANIMATIONS = 25;
 
-const int HEADER_SIZE = (11 * 4) + MAX_QPATH;
-const int FRAME_SIZE = ( 3 * ( 3 * 4 ) + 4 + 16 );
-const int TAG_SIZE = ( MAX_QPATH + ( 4 * 3 ) + ( 3 * 4 * 3 ) );
+const int MD3_HEADER_SIZE = (11 * 4) + MAX_QPATH; // Same for model and each mesh in model
+const int MD3_FRAME_SIZE = ( 3 * ( 3 * 4 ) + 4 + 16 );
+const int MD3_TAG_SIZE = ( MAX_QPATH + ( 4 * 3 ) + ( 3 * 4 * 3 ) );
+#ifdef MDR_GENERAL
+const int MDR_HEADER_SIZE = (10 * 4) + MAX_QPATH; // model header size, mesh header must add MAX_QPATH
+const int MDR_FRAME_SIZE = MD3_FRAME_SIZE; // NOTE: must add (numBones * MDR_BONE_SIZE)
+const int MDR_BONE_SIZE = (4 * (3 * 4) );
+const int MDR_LOD_SIZE = (3 * 4);
+//const int MDR_TAG_SIZE = 32 + 4; // unused
+#endif
 
 
 const char s_animNames[ MD3_ANIMATIONS ][16] = 
@@ -97,64 +104,16 @@
    "legs_turn",
 };
 
-int s_animLoop[ MD3_ANIMATIONS ] = 
+// ZTM: TODO: Allow user to have any animation have sync warning? (Or at least disable?)
+const char *s_animSyncWarning[] =
 {
-   0, // both_death1
-   0, // both_dead1
-   0, // both_death2
-   0, // both_dead2
-   0, // both_death3
-   0, // both_dead3
-   0, // torso_gesture
-   0, // torso_attack
-   0, // torso_attack2
-   0, // torso_drop
-   0, // torso_raise
-   1, // torso_stand
-   1, // torso_stand2
-   1, // legs_walkcr
-   1, // legs_walk
-   1, // legs_run
-   1, // legs_back
-   1, // legs_swim
-   0, // legs_jump
-   0, // legs_land
-   0, // legs_jumpb
-   0, // legs_landb
-   1, // legs_idle
-   1, // legs_idlecr
-   1, // legs_turn
+   "torso_attack",
+   "torso_attack2",
+   "torso_drop",
+   "torso_raise",
+   NULL
 };
 
-int s_animSyncWarning[ MD3_ANIMATIONS ] = 
-{
-   0, // both_death1
-   0, // both_dead1
-   0, // both_death2
-   0, // both_dead2
-   0, // both_death3
-   0, // both_dead3
-   0, // torso_gesture
-   1, // torso_attack
-   1, // torso_attack2
-   1, // torso_drop
-   1, // torso_raise
-   0, // torso_stand
-   0, // torso_stand2
-   0, // legs_walkcr
-   0, // legs_walk
-   0, // legs_run
-   0, // legs_back
-   0, // legs_swim
-   0, // legs_jump
-   0, // legs_land
-   0, // legs_jumpb
-   0, // legs_landb
-   0, // legs_idle
-   0, // legs_idlecr
-   0, // legs_turn
-};
-
 Md3Filter::Md3Filter()
 {
 }
@@ -163,6 +122,28 @@
 {
 }
 
+#ifdef MDR_GENERAL
+bool Md3Filter::isMdr(const char *filename)
+{
+   unsigned len = strlen( filename );
+
+   return ( len >= 4 && strcasecmp( &filename[len-4], ".mdr" ) == 0 );
+}
+
+Model::AnimationModeE Md3Filter::animMode(Md3Filter::MeshTypeE type)
+{
+
+   if (type == MT_MDR)
+   {
+      return Model::ANIMMODE_SKELETAL;
+   }
+   else // MT_MD3
+   {
+      return Model::ANIMMODE_FRAME;
+   }
+}
+#endif
+
 Model::ModelErrorE Md3Filter::readFile( Model * model, const char * const filename )
 {
    if ( model && filename && filename[0] )
@@ -202,14 +183,25 @@
       string lowerFile = m_modelPath + fixFileCase( m_modelPath.c_str(), "lower.md3" );
       string upperFile = m_modelPath + fixFileCase( m_modelPath.c_str(), "upper.md3" );
       string headFile  = m_modelPath + fixFileCase( m_modelPath.c_str(), "head.md3"  );
+#ifdef MDR_LOAD
+      string lowerFileMDR = m_modelPath + fixFileCase( m_modelPath.c_str(), "lower.mdr" );
+      string upperFileMDR = m_modelPath + fixFileCase( m_modelPath.c_str(), "upper.mdr" );
+      string headFileMDR  = m_modelPath + fixFileCase( m_modelPath.c_str(), "head.mdr"  );
+#endif
 
       if (     strncasecmp( m_modelBaseName.c_str(), "lower.", 6 ) == 0 
             || strncasecmp( m_modelBaseName.c_str(), "upper.", 6 ) == 0 
             || strncasecmp( m_modelBaseName.c_str(), "head.",  5 ) == 0 )
       {
+#ifdef MDR_LOAD
+         if ( (file_exists( lowerFile.c_str() ) || file_exists( lowerFileMDR.c_str() ))
+               && (file_exists( upperFile.c_str() ) || file_exists( upperFileMDR.c_str() ))
+               && (file_exists( headFile.c_str() ) || file_exists( headFileMDR.c_str() )) )
+#else
          if ( file_exists( lowerFile.c_str() )
                && file_exists( upperFile.c_str() )
                && file_exists( headFile.c_str() ) )
+#endif
          {
             log_debug( "have all files for %s\n", m_modelPath.c_str() );
 
@@ -235,7 +227,20 @@
          Md3FileDataT fd;
 
          fd.section = MS_Lower;
+#ifdef MDR_LOAD
+         if ( file_exists( lowerFileMDR.c_str() ) )
+         {
+            fd.type = MT_MDR;
+         	fd.modelBaseName = "lower.mdr";
+         }
+         else
+         {
+            fd.type = MT_MD3;
+            fd.modelBaseName = "lower.md3";
+         }
+#else
          fd.modelBaseName = "lower.md3";
+#endif
          fd.modelFile = lowerFile;
          fd.tag = "";
          fd.tagPoint = -1;
@@ -248,13 +253,39 @@
          fileList.push_back( fd );
 
          fd.section = MS_Upper;
+#ifdef MDR_LOAD
+         if ( file_exists( upperFileMDR.c_str() ) )
+         {
+            fd.type = MT_MDR;
+         	fd.modelBaseName = "upper.mdr";
+         }
+         else
+         {
+            fd.type = MT_MD3;
+            fd.modelBaseName = "upper.md3";
+         }
+#else
          fd.modelBaseName = "upper.md3";
+#endif
          fd.modelFile = upperFile;
          fd.tag = "tag_torso";
          fileList.push_back( fd );
 
          fd.section = MS_Head;
+#ifdef MDR_LOAD
+         if ( file_exists( headFileMDR.c_str() ) )
+         {
+            fd.type = MT_MDR;
+         	fd.modelBaseName = "head.mdr";
+         }
+         else
+         {
+            fd.type = MT_MD3;
+         	fd.modelBaseName = "head.md3";
+         }
+#else
          fd.modelBaseName = "head.md3";
+#endif
          fd.modelFile = headFile;
          fd.tag = "tag_head";
          fileList.push_back( fd );
@@ -263,6 +294,16 @@
       {
          Md3FileDataT fd;
 
+#ifdef MDR_LOAD
+         if ( isMdr(m_modelBaseName.c_str()) )
+         {
+            fd.type = MT_MDR;
+         }
+         else
+         {
+            fd.type = MT_MD3;
+         }
+#endif
          fd.section = MS_None;
          fd.modelBaseName = m_modelBaseName;
          fd.modelFile = filename;
@@ -306,6 +347,12 @@
 
          m_model = model;
 
+#ifdef MDR_LOAD
+         m_animationMode = animMode((*it).type);
+#else
+         m_animationMode = Model::ANIMMODE_FRAME;
+#endif
+
          Matrix loadMatrix;
          loadMatrix.setRotationInDegrees( -90, -90, 0 );
 
@@ -316,6 +363,101 @@
          readString( pk3Name, sizeof( pk3Name ) );
          replaceBackslash( pk3Name );
 
+#ifdef MDR_LOAD
+         // MD3 header data.
+         int32_t flags = 0; // MD3 only
+         int32_t numFrames = 0;
+         int32_t numTags = 0;
+         int32_t numMeshes = 0; // MD3 only
+         int32_t numSkins = 0; // MD3 only
+         int32_t offsetFrames = 0;
+         int32_t offsetTags = 0;
+         int32_t offsetMeshes = 0; // MD3 only
+         int32_t offsetEnd = 0;
+
+         // MDR header data.
+         //int32_t numFrames = 0;
+         int32_t numBones = 0;
+         //int32_t offsetFrames = 0;
+         int32_t numLODs = 0;
+         int32_t offsetLODs = 0;
+         //int32_t numTags = 0;
+         //int32_t offsetTags = 0;
+         //int32_t offsetEnd = 0;
+
+         if ((*it).type == MT_MDR)
+         {
+            numFrames = m_src->readI32();
+            numBones = m_src->readI32();
+            offsetFrames = m_src->readI32();
+            numLODs = m_src->readI32();
+            offsetLODs = m_src->readI32();
+            numTags = m_src->readI32();
+            offsetTags = m_src->readI32();
+            offsetEnd = m_src->readI32();
+
+            log_debug( "Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+            log_debug( "Version: %d\n",     version );
+            log_debug( "PK3 Name: %s\n",    pk3Name );
+            log_debug( "Frames: %d\n",      numFrames );
+            log_debug( "Bones: %d\n",    numBones );
+            log_debug( "Offset Frames: %d\n",      offsetFrames );
+            log_debug( "LODs: %d\n",       numLODs );
+            log_debug( "Offset LODs: %d\n",      offsetLODs );
+            log_debug( "Tags: %d\n",        numTags );
+            log_debug( "Offset Tags: %d\n",  offsetTags );
+            log_debug( "Offset End: %d\n",        offsetEnd );
+            log_debug( "File Length: %d\n",       m_src->getFileSize() );
+
+            if ( magic[0] != 'R' && magic[1] != 'D' && magic[2] != 'M' && magic[3] != '5' )
+            {
+               log_debug( "Bad Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+               return Model::ERROR_BAD_MAGIC;
+            }
+
+            if ( version != MDR_VERSION )
+            {
+               return Model::ERROR_UNSUPPORTED_VERSION;
+            }
+         }
+         else // MT_MD3
+         {
+            flags = m_src->readI32();
+            numFrames = m_src->readI32();
+            numTags = m_src->readI32();
+            numMeshes = m_src->readI32();
+            numSkins = m_src->readI32();
+            offsetFrames = m_src->readI32();
+            offsetTags = m_src->readI32();
+            offsetMeshes = m_src->readI32();
+            offsetEnd = m_src->readI32();
+
+            log_debug( "Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+            log_debug( "Version: %d\n",     version );
+            log_debug( "PK3 Name: %s\n",    pk3Name );
+            log_debug( "Flags: %d\n",    flags );
+            log_debug( "Frames: %d\n",      numFrames );
+            log_debug( "Tags: %d\n",        numTags );
+            log_debug( "Meshes: %d\n",    numMeshes );
+            log_debug( "Skins: %d\n",       numSkins );
+            log_debug( "Offset Frames: %d\n",      offsetFrames );
+            log_debug( "Offset Tags: %d\n",  offsetTags );
+            log_debug( "Offset Meshes: %d\n",  offsetMeshes );
+            log_debug( "Offset End: %d\n",        offsetEnd );
+            log_debug( "File Length: %d\n",       m_src->getFileSize() );
+
+            if ( magic[0] != 'I' && magic[1] != 'D' && magic[2] != 'P' && magic[3] != '3' )
+            {
+               log_debug( "Bad Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+               return Model::ERROR_BAD_MAGIC;
+            }
+
+            if ( version != MD3_VERSION )
+            {
+               return Model::ERROR_UNSUPPORTED_VERSION;
+            }
+         }
+#else
          int32_t flags = m_src->readI32();
          int32_t numFrames = m_src->readI32();
          int32_t numTags = m_src->readI32();
@@ -350,6 +492,7 @@
          {
             return Model::ERROR_UNSUPPORTED_VERSION;
          }
+#endif
 
          
          Md3PathT mpath;
@@ -364,6 +507,10 @@
          // frames
          // mm3d doesn't need this, but nice to have if you ever need to debug
 
+#ifdef MDR_LOAD
+         if ((*it).type == MT_MD3)
+         {
+#endif
 #if 0
          m_src->seek( offsetFrames );
          for ( int i = 0; i < numFrames; i++ )
@@ -398,6 +545,9 @@
             log_debug( "Frame %d name: %s\n", i, frameName );
          }
 #endif // 1
+#ifdef MDR_LOAD
+         }
+#endif
 
          if ( (*it).tag.size() > 0 )
          {
@@ -405,9 +555,16 @@
             log_debug( "tag point for %s is %d\n", (*it).tag.c_str(), (*it).tagPoint );
          }
 
+#ifdef MDR_LOAD
+         if ((*it).type == MT_MD3)
+         {
+#endif
          m_meshVecInfos = new MeshVectorInfoT*[numMeshes];
          setPoints( (*it).section, offsetTags, numTags, numFrames, (*it).tagPoint, -1 );
          setMeshes( (*it).section, offsetMeshes, numMeshes, (*it).tagPoint, -1 );
+#ifdef MDR_LOAD
+         }
+#endif
 
          (*it).meshVecInfos = m_meshVecInfos;
          (*it).src = m_src;
@@ -416,24 +573,34 @@
          (*it).offsetTags = offsetTags;
          (*it).numTags = numTags;
          (*it).numFrames = numFrames;
+#ifdef MDR_LOAD
+         (*it).numBones = numBones;
+         (*it).numLODs = numLODs;
+         (*it).offsetLODs = offsetLODs;
+#endif
       }
 
       if ( fileList.front().numFrames > 1 )
       {
          log_debug( "Model has animation, setting up animation mode.\n" );
-         if ( m_model->getAnimCount( Model::ANIMMODE_FRAME ) == 0 )
+         if ( m_model->getAnimCount( m_animationMode ) == 0 )
          {
             if ( !loadAll || !readAnimations( true ) )
             {
-               int animIndex = m_model->addAnimation( Model::ANIMMODE_FRAME, "AnimFrames" );
-               m_model->setAnimFPS( Model::ANIMMODE_FRAME, animIndex, 15.0);
-               m_model->setAnimFrameCount( Model::ANIMMODE_FRAME, 0, fileList.front().numFrames );
+               int animIndex = m_model->addAnimation( m_animationMode, "AnimFrames" );
+               m_model->setAnimFPS( m_animationMode, animIndex, 15.0);
+               m_model->setAnimFrameCount( m_animationMode, animIndex, fileList.front().numFrames );
+               m_model->setAnimationLooping( m_animationMode, animIndex, false );
             }
          }
       }
 
       for ( it = fileList.begin(); it != fileList.end(); it++ )
       {
+#ifdef MDR_LOAD
+         if ((*it).type != MT_MD3)
+            continue;
+#endif
          m_meshVecInfos = (*it).meshVecInfos;
          m_src = (*it).src;
 
@@ -500,11 +667,18 @@
       // Clean-up
       for ( it = fileList.begin(); it != fileList.end(); it++ )
       {
+#ifdef MDR_LOAD
+         if ((*it).type == MT_MD3)
+         {
+#endif
          for ( int i = 0; i < (*it).numMeshes; i++ )
          {
             delete[] (*it).meshVecInfos[i];
          }
          delete[] (*it).meshVecInfos;
+#ifdef MDR_LOAD
+         }
+#endif
 
          (*it).src->close();
          (*it).src = NULL;
@@ -531,6 +705,10 @@
    string animFile = m_modelPath + "animation.cfg";
    FILE * fp = fopen( animFile.c_str(), "r" );
    int animCount = 0;
+   std::vector<std::string> animNames;
+   int last_fcount = 0;
+   bool eliteLoop = false;
+   int animKeyword = 0;
 
    m_animStartFrame.clear();
    m_standFrame = 0;
@@ -563,21 +741,88 @@
             int fcount = 0;
             int loop   = 0;
             int fps    = 0;
-            if ( sscanf( line, "%d %d %d %d",
-                     &first, &fcount, &loop, &fps ) == 4 )
+			char comment[128] = { 0 }; // May hold "//" or "//BOTH_x..."
+			char fname[128] = { 0 }; // May hold "BOTH_x..."
+
+			// Loads the following types
+			// "0 5 5 15"
+			// "0 5 5 15 //"
+			// "0 5 5 15 //BOTH_DEATH1"
+			// "0 5 5 15 // BOTH_DEATH1"
+			// "0 5 5 15 //         BOTH_DEATH1"
+			// "BOTH_DEATH1 0 5 5 15" (Elite Force Single Player style)
+			// If EF SP style, must check if valid animation name
+			//   (or metadata could be loaded as animation)
+
+            if ( sscanf( line, "%d %d %d %d %s %s",
+                   &first, &fcount, &loop, &fps, comment, fname ) >= 4
+			    || (sscanf( line, "%s %d %d %d %d",
+                      fname, &first, &fcount, &loop, &fps ) == 5
+				    && (strncasecmp(fname, "both_", 5) == 0 || strncasecmp(fname, "torso_", 6) == 0
+                      || strncasecmp(fname, "legs_", 5) == 0) && (animKeyword || (animKeyword = 1)) ))
             {
                log_debug( "got anim frame details\n" );
-               if ( animCount == 11 )
+
+               // Check for animations that are played in reverse
+               if (fcount < 0)
                {
-                  m_standFrame = first;
+                  // ZTM: FIXME: Make a note that it is reversed?
+                  fcount = abs(fcount);
                }
-               else if ( animCount == 22 )
+
+               if (create && loop == -1 && !eliteLoop)
                {
-                  m_idleFrame = first;
+                  m_model->addMetaData( "MD3_EliteLoop", "1" );
+                  eliteLoop = true;
                }
 
-               if ( animCount < 6 )
+               if (create && animKeyword == 1)
                {
+                  m_model->addMetaData( "MD3_AnimKeyword", "1" );
+                  animKeyword = 2; // Avoid setting MD3_AnimKeyword each time
+               }
+
+               char * name = NULL;
+
+               // Check if read name from file.
+               if (strlen(comment) > 7 || strlen(fname) > 5)
+               {
+                  // "//BOTH_x..."
+                  if (strlen(comment) > 7)
+                  {
+                     name = &comment[2];
+                  }
+                  // "BOTH_x..."
+                  else //if (strlen(fname) > 5)
+                  {
+                     name = fname;
+                  }
+
+                  for ( int i = 0; name[i]; i++ )
+                  {
+                     name[i] = tolower( name[i] );
+                  }
+               }
+               else
+               {
+                  // Failed to load name from file, use default.
+                  if ( animCount < MD3_ANIMATIONS )
+                  {
+                     // I won't change it, I promise
+                     name = (char *) s_animNames[ animCount ];
+                  }
+                  else
+                  {
+                     name = (char *) "Unknown";
+                  }
+               }
+
+               // Save name for offset fixing after animations are loaded.
+               animNames.push_back(name);
+
+               // It's a "both_" animation
+               if ( strncasecmp( name, "both_", 5 ) == 0 )
+               {
                   if ( first + fcount > legsEnd )
                   {
                      if ( bothStart == -1 )
@@ -591,8 +836,20 @@
                         bothEnd = std::max(bothEnd, first + fcount);
                      }
                   }
+
+                  // Check for single frame dead animation that use the last
+                  //   frame of the death animation
+                  if (animCount > 0 && strncasecmp(name, "both_dead", 9) == 0
+                     && strncasecmp(animNames[animCount-1].c_str(), "both_death", 10) == 0
+                     && fcount <= 1 )
+                  {
+                     if (m_animStartFrame[animCount-1] + last_fcount - 1 == first)
+                     {
+                        fcount = 0;
+                     }
+                  }
                }
-               else if ( animCount < 13 )
+               else if ( strncasecmp( name, "torso_", 6 ) == 0 )
                {
                   if ( first + fcount > legsEnd )
                   {
@@ -607,8 +864,13 @@
                         torsoEnd = std::max(torsoEnd, first + fcount);
                      }
                   }
+
+                  if ( strcasecmp(name, "torso_stand") == 0 )
+                  {
+                     m_standFrame = first;
+                  }
                }
-               else
+               else if ( strncasecmp( name, "legs_", 5 ) == 0 )
                {
                   if ( legsStart == -1 )
                   {
@@ -620,122 +882,89 @@
                      legsStart = std::min(legsStart, first);
                      legsEnd = std::max(legsEnd, first + fcount);
                   }
+
+                  if ( strcasecmp(name, "legs_idle") == 0 )
+                  {
+                     m_idleFrame = first;
+                  }
                }
+				else
+				{
+					// Unknown animation
+					log_debug( "unknown animation type-prefix '%s'\n", name );
+				}
 
                m_animStartFrame.push_back( first );
 
                if ( create )
                {
-                  const char * name = NULL;
-                  if ( animCount < MD3_ANIMATIONS )
+                  log_debug( "adding animation '%s'\n", name );
+                  int animIndex = m_model->addAnimation( m_animationMode, name );
+                  m_model->setAnimFPS( m_animationMode, animIndex, (double) fps );
+                  m_model->setAnimFrameCount( m_animationMode, animIndex, fcount );
+
+                  // Set looping
+                  if (eliteLoop)
                   {
-                     // I won't change it, I promise
-                     name = (char *) s_animNames[ animCount ];
+                     m_model->setAnimationLooping( m_animationMode, animIndex, (loop == 0) );
                   }
                   else
                   {
-                     char * tempname = strrchr( line, '/' );
-                     if ( tempname )
-                     {
-                        tempname++;
-                        while ( isspace(tempname[0]) )
-                        {
-                           tempname++;
-                        }
-                        int end = 0;
-                        while ( tempname[end] && !isspace(tempname[end]) )
-                        {
-                           end++;
-                        }
-                        tempname[end] = '\0';
-
-                        for ( end = 0; line[end]; end++ )
-                        {
-                           tempname[end] = tolower( line[end] );
-                        }
-                        name = tempname;
-                     }
-                     else
-                     {
-                        name = "Unknown";
-                     }
+                     m_model->setAnimationLooping( m_animationMode, animIndex, (loop != 0) );
                   }
-
-                  log_debug( "adding animation '%s'\n", name );
-                  int animIndex = m_model->addAnimation( Model::ANIMMODE_FRAME, s_animNames[ animCount ] );
-                  m_model->setAnimFPS( Model::ANIMMODE_FRAME, animIndex, (double) fps );
-                  m_model->setAnimFrameCount( Model::ANIMMODE_FRAME, animIndex, fcount );
                }
 
                animCount++;
+               last_fcount = fcount;
             }
             else
             {
                if ( create )
                {
-                  char * value = NULL;
-                  if ( strncasecmp( line, "sex", 3 ) == 0 )
+                  bool checkValue = false;
+                  char *name = NULL;
+                  std::string str;
+
+                  // save "name value"
+                  name = line;
+                  while( isspace(name[0]) )
                   {
-                     // sex (m,f,n)
-                     value = &line[3];
-                     while( isspace(value[0]) )
-                     {
-                        value++;
-                     }
-                     int end = 0;
-                     while ( value[end] && !isspace( value[end] ) )
-                     {
-                        end++;
-                     }
-                     value[end] = '\0';
-
-                     m_model->addMetaData( "MD3_sex", value );
+                     name++;
                   }
-                  else if ( strncasecmp( line, "footsteps", 9 ) == 0 )
+                  int end = 0;
+                  while ( name[end] && name[end] != '\r' && name[end] != '\n' )
                   {
-                     // footsteps (normal,boot,flesh,mech)
-                     value = &line[9];
-                     while( isspace(value[0]) )
+                     if (isspace(name[end]))
                      {
-                        value++;
+                        checkValue = true;
+                        break;
                      }
-                     int end = 0;
-                     while ( value[end] && !isspace( value[end] ) )
-                     {
-                        end++;
-                     }
-                     value[end] = '\0';
+                     end++;
+                  }
+                  name[end] = '\0';
+                  end++;
+                  str = "MD3_CFG_";
+                  str += name;
 
-                     m_model->addMetaData( "MD3_footsteps", value );
-                  }
-                  else if ( strncasecmp( line, "headoffset", 10 ) == 0 )
+                  if (checkValue)
                   {
-                     // headoffset %d %d %d
-                     value = &line[10];
+                     char *value = &name[end];
                      while( isspace(value[0]) )
                      {
                         value++;
                      }
-                     int end = 0;
+                     end = 0;
                      while ( value[end] && value[end] != '\r' && value[end] != '\n' )
                      {
                         end++;
                      }
                      value[end] = '\0';
 
-                     m_model->addMetaData( "MD3_headoffset", value );
+                     m_model->addMetaData( str.c_str(), value );
                   }
-                  else if ( strncasecmp( line, "fixedtorso", 10 ) == 0 )
-                  {
-                     m_model->addMetaData( "MD3_fixedtorso", "" );
-                  }
-                  else if ( strncasecmp( line, "fixedlegs", 9 ) == 0 )
-                  {
-                     m_model->addMetaData( "MD3_fixedlegs", "" );
-                  }
                   else
                   {
-                     log_warning( "Unknown meta data: %s", line );
+                     m_model->addMetaData( str.c_str(), "" );
                   }
                }
             }
@@ -744,6 +973,18 @@
 
       fclose( fp );
 
+      if (m_standFrame == 0)
+      {
+         // Didn't find "torso_stand", use first torso frame
+         m_standFrame = torsoStart;
+      }
+
+      if (m_idleFrame == 0)
+      {
+         // Didn't find "legs_idle", use first legs frame
+         m_idleFrame = legsStart;
+      }
+
       // Some animation files have the leg frames continuously numbered 
       // after the torso frames, others number the legs following the
       // "both" frames. Here we are adjusting the first case to make
@@ -752,8 +993,10 @@
       if ( legsStart >= torsoEnd )
       {
          int animOffset = legsStart - torsoStart;
-         for ( size_t a = 13; a < m_animStartFrame.size(); ++a )
+         for ( size_t a = 0; a < m_animStartFrame.size(); ++a )
          {
+            if ( strncasecmp( animNames[a].c_str(), "legs_", 5 ) != 0 )
+               continue;
             if ( m_animStartFrame[a] >= animOffset )
                m_animStartFrame[a] -= animOffset;
          }
@@ -1547,6 +1790,28 @@
    return false;
 }
 
+#ifdef MDR_EXPORT
+bool Md3Filter::boneJointInSection( std::string jointName, MeshSectionE section )
+{
+   if ( groupInSection(jointName, section) )
+   {
+      // not a player model or specificly defined as part of this section
+      return true;
+   }
+
+   if ( strncasecmp( jointName.c_str(), "joint_tag", 9) == 0 )
+   {
+      return tagInSection(&jointName[5], section);
+   }
+   if ( strcasecmp( jointName.c_str(), "root_joint") == 0 )
+   {
+      return (section == MS_Lower);
+   }
+
+   return false;
+}
+#endif
+
 bool Md3Filter::tagInSection( std::string tagName, MeshSectionE section )
 {
    if ( section == MS_None )
@@ -1569,13 +1834,31 @@
          return true;
       }
    }
-   else if ( strcasecmp( tagName.c_str(), "tag_weapon" ) == 0 )
+   else if ( strcasecmp( tagName.c_str(), "tag_weapon" ) == 0
+      // ZTM: FIXME: Game specific
+      // Support Team Arena tag point
+      || strcasecmp( tagName.c_str(), "tag_flag" ) == 0
+#ifdef TURTLE_ARENA // New tags for Turtle Arena
+      || strcasecmp( tagName.c_str(), "tag_hand_primary" ) == 0
+      || strcasecmp( tagName.c_str(), "tag_hand_secondary" ) == 0
+      || strcasecmp( tagName.c_str(), "tag_wp_away_primary" ) == 0
+      || strcasecmp( tagName.c_str(), "tag_wp_away_secondary" ) == 0
+#endif
+      )
    {
       if ( section == MS_Upper )
       {
          return true;
       }
    }
+   else
+   {
+      // Support unknown tags. Mods can add new tags.
+      //   Better to have unknown tag in all models then none.
+      // In Quake3 the programmer selects which section the tag is on,
+      //   so it should be harmless (Other then the larger file size in the models that don't use the tag...).
+      return true;
+   }
 
    return false;
 }
@@ -1614,9 +1897,9 @@
 {
    std::string animName = "none";
 
-   if ( anim < m_model->getAnimCount( Model::ANIMMODE_FRAME ) )
+   if ( anim < m_model->getAnimCount( m_animationMode ) )
    {
-      animName = m_model->getAnimName( Model::ANIMMODE_FRAME, anim );
+      animName = m_model->getAnimName( m_animationMode, anim );
    }
 
    return animName;
@@ -1624,6 +1907,9 @@
  
 Model::ModelErrorE Md3Filter::writeFile( Model * model, const char * const filename, ModelFilter::Options *  )
 {
+#ifdef MDR_EXPORT
+   log_enable_debug(true);
+#endif
    if ( model && filename && filename[0] )
    {
       unsigned tcount = model->getTriangleCount();
@@ -1682,7 +1968,11 @@
       if ( haveUpper && haveLower )
       {
          if (  m_model->getPointByName( "tag_torso" )  < 0
+#ifdef TURTLE_ARENA // Turtle Arena supports using tag_hand_primary as well as tag_weapon ...
+            || (m_model->getPointByName( "tag_weapon" ) < 0 && m_model->getPointByName( "tag_hand_primary" ) < 0)
+#else
             || m_model->getPointByName( "tag_weapon" ) < 0
+#endif
             || m_model->getPointByName( "tag_head" )   < 0 )
          {
             // missing required tags for player model
@@ -1713,8 +2003,20 @@
             }
             else
             {
-               // TODO: Eventually create a prompt instead of assuming "yes"
-               log_debug( "model is implicitly a composite (no composite meta tag)\n" );
+		        char answer = msg_info_prompt( transll( QT_TRANSLATE_NOOP( "LowLevel", "This looks like a player model.\nDo you want to save all sections?")).c_str(), "Ync" );
+		        if ( answer == 'Y' )
+		        {
+		           model->addMetaData( "MD3_composite", "1" );
+		        }
+		        else if ( answer == 'N' )
+		        {
+		           model->addMetaData( "MD3_composite", "0" );
+		           saveAsPlayer = false;
+		        }
+		        else
+		        {
+		           return Model::ERROR_CANCEL;
+		        }
             }
          }
          else
@@ -1730,7 +2032,29 @@
 
          std::string playerFile;
          std::string path = modelPath + "/";
+#ifdef MDR_EXPORT
+         if ( isMdr(modelBaseName.c_str()) )
+         {
+            playerFile = path + fixFileCase( m_modelPath.c_str(), "lower.mdr" );
+            writeSectionFile( playerFile.c_str(), MT_MDR, MS_Lower, meshes );
 
+            playerFile = path + fixFileCase( m_modelPath.c_str(), "upper.mdr" );
+            writeSectionFile( playerFile.c_str(), MT_MDR, MS_Upper, meshes );
+         }
+         else
+         {
+            playerFile = path + fixFileCase( m_modelPath.c_str(), "lower.md3" );
+            writeSectionFile( playerFile.c_str(), MT_MD3, MS_Lower, meshes );
+
+            playerFile = path + fixFileCase( m_modelPath.c_str(), "upper.md3" );
+            writeSectionFile( playerFile.c_str(), MT_MD3, MS_Upper, meshes );
+         }
+
+         playerFile = path + fixFileCase( m_modelPath.c_str(), "head.md3" );
+         writeSectionFile( playerFile.c_str(), MT_MD3, MS_Head,  meshes );
+
+         m_animationMode = animMode(isMdr(modelBaseName.c_str()) ? MT_MDR : MT_MD3);
+#else
          playerFile = path + fixFileCase( m_modelPath.c_str(), "lower.md3" );
          writeSectionFile( playerFile.c_str(), MS_Lower, meshes );
 
@@ -1739,15 +2063,26 @@
 
          playerFile = path + fixFileCase( m_modelPath.c_str(), "head.md3" );
          writeSectionFile( playerFile.c_str(), MS_Head,  meshes );
+#endif
 
          writeAnimations();
 
+#ifdef MDR_EXPORT
+         log_enable_debug(false);
+#endif
+
          return Model::ERROR_NONE;
       }
       else
       {
          log_debug( "saving as a single model\n" );
+#ifdef MDR_EXPORT
+         writeSectionFile( filename, isMdr(modelBaseName.c_str()) ? MT_MDR : MT_MD3, MS_None, meshes );
+         log_enable_debug(false);
+         return Model::ERROR_NONE;
+#else
          return writeSectionFile( filename, MS_None, meshes );
+#endif
       }
    }
    else
@@ -1757,11 +2092,21 @@
    }
 }
 
+#ifdef MDR_EXPORT
+Model::ModelErrorE Md3Filter::writeSectionFile( const char * filename, Md3Filter::MeshTypeE type,
+      Md3Filter::MeshSectionE section, MeshList & meshes )
+#else
 Model::ModelErrorE Md3Filter::writeSectionFile( const char * filename, Md3Filter::MeshSectionE section, MeshList & meshes )
+#endif
 {
    string modelPath = "";
    string modelBaseName = "";
    string modelFullName = "";
+#ifdef MDR_EXPORT
+   m_animationMode = animMode(type);
+#else
+   m_animationMode = Model::ANIMMODE_FRAME;
+#endif
 
    log_debug( "writing section file %s\n", filename );
    switch ( section )
@@ -1785,6 +2130,27 @@
 
    normalizePath( filename, modelFullName, modelPath, modelBaseName );
 
+#ifdef MDR_EXPORT
+   int8_t magic[4];
+   int32_t version = 0;
+   if (type == MT_MDR)
+   {
+      //MDR HEADER
+      magic[0] = 'R';
+      magic[1] = 'D';
+      magic[2] = 'M';
+      magic[3] = '5';
+      version = MDR_VERSION;
+   }
+   else
+   {
+      magic[0] = 'I';
+      magic[1] = 'D';
+      magic[2] = 'P';
+      magic[3] = '3';
+      version = MD3_VERSION;
+   }
+#else
    //MD3 HEADER
    int8_t magic[4];
    magic[0] = 'I';
@@ -1792,6 +2158,7 @@
    magic[2] = 'P';
    magic[3] = '3';
    int32_t version = MD3_VERSION;
+#endif
    char pk3Name[MAX_QPATH];
    std::string pk3Path = "";
    memset( pk3Name, 0, MAX_QPATH );
@@ -1814,14 +2181,14 @@
    int32_t flags = 0;
    int32_t numFrames = 0;
    //We are making all the anims be one anim.
-   unsigned animCount = m_model->getAnimCount( Model::ANIMMODE_FRAME );
+   unsigned animCount = m_model->getAnimCount( m_animationMode );
    for ( unsigned i = 0; i < animCount; i++ )
    {
       // Skip animations that don't belong in this section
       std::string name = getSafeName( i );
       if ( animInSection( name, section ) )
       {
-         numFrames += m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, i );
+         numFrames += m_model->getAnimFrameCount( m_animationMode, i );
       }
    }
 
@@ -1843,17 +2210,17 @@
 
    unsigned pcount = m_model->getPointCount();
    int32_t numTags = (int32_t) pcount;
-   switch ( section )
+   // If spliting model, count tags.
+   if (section == MS_Head || section == MS_Lower || section == MS_Upper)
    {
-      case MS_Head:
-      case MS_Lower:
-         numTags = 1;
-         break;
-      case MS_Upper:
-         numTags = 3;
-         break;
-      default:
-         break;
+      numTags = 0;
+      for ( unsigned j = 0; j < pcount; j++ )
+      {
+         if ( tagInSection( m_model->getPointName( j ), section ) )
+         {
+            numTags++;
+         }
+      }
    }
 
    MeshList::iterator mlit;
@@ -1880,7 +2247,7 @@
       }
    }
 
-   int32_t numSkins = 0;
+   int32_t numSkins = 0; // MD3
    if ( numTags > MD3_MAX_TAGS )
    {
       log_error( "Number of tags(%d) is larger than %d\n.\n", numTags, MD3_MAX_TAGS );
@@ -1894,10 +2261,59 @@
       return Model::ERROR_FILTER_SPECIFIC;
    }
    // numSkins is usually zero for MD3 header, there can be skins for each mesh though later
-   int32_t offsetFrames = HEADER_SIZE;
-   int32_t offsetTags = offsetFrames + numFrames * FRAME_SIZE;
-   int32_t offsetMeshes = offsetTags + numFrames * numTags * TAG_SIZE;
+#ifdef MDR_EXPORT
+   int32_t numBones = 0; // MDR
+   int32_t offsetFrames = 0;
+   int32_t numLODs = 0; // MDR
+   int32_t offsetLODs = 0; // MDR
+   int32_t offsetTags = 0;
+   int32_t offsetMeshes = 0; // MD3
+   int32_t offsetEnd = 0;
+   int32_t compress = 0; // MDR
+   unsigned bcount = 0; // MDR
+   unsigned bonesRemap[1024]; // Remap MM3D's bone indexes to the local model
+                              // ZTM: FIXME: What should be max be? (ioquake3 defines MDR_MAX_BONES to 128, but never uses it)
+   if (type == MT_MDR)
+   {
+      bcount = m_model->getBoneJointCount();
+      memset(bonesRemap, 0, sizeof (bonesRemap));
+      if (section == MS_Head || section == MS_Lower || section == MS_Upper)
+      {
+         numBones = 0;
+         for ( unsigned j = 0; j < bcount; j++ )
+         {
+            if ( boneJointInSection( m_model->getBoneJointName( j ), section ) )
+            {
+               bonesRemap[j] = numBones;
+               numBones++;
+            }
+         }
+      }
+      else
+      {
+         numBones = (int32_t) bcount;
+      }
+
+      offsetFrames = MDR_HEADER_SIZE;
+      numLODs = 1;
+      offsetLODs = offsetFrames + numFrames * (MDR_FRAME_SIZE + numBones * MDR_BONE_SIZE);
+      offsetMeshes = offsetLODs + numLODs * MDR_LOD_SIZE; // First LOD's meshes
+      offsetTags = offsetMeshes; // Note: Plus size of meshes!
+      offsetEnd = offsetTags;
+   }
+   else
+   {
+      offsetFrames = MD3_HEADER_SIZE;
+      offsetTags = offsetFrames + numFrames * MD3_FRAME_SIZE;
+      offsetMeshes = offsetTags + numFrames * numTags * MD3_TAG_SIZE;
+      offsetEnd = offsetMeshes;
+   }
+#else
+   int32_t offsetFrames = MD3_HEADER_SIZE;
+   int32_t offsetTags = offsetFrames + numFrames * MD3_FRAME_SIZE;
+   int32_t offsetMeshes = offsetTags + numFrames * numTags * MD3_TAG_SIZE;
    int32_t offsetEnd = offsetMeshes;
+#endif
 
    // MD3 limit tests
    if ( numTris > MD3_MAX_TRIANGLES )
@@ -1922,6 +2338,29 @@
       return err;
 
    // write file header
+#ifdef MDR_EXPORT
+   if (type == MT_MDR)
+   {
+      m_dst->write( magic[0] );
+      m_dst->write( magic[1] );
+      m_dst->write( magic[2] );
+      m_dst->write( magic[3] );
+      m_dst->write( version );
+      m_dst->writeBytes( (uint8_t*) pk3Name, MAX_QPATH );
+      m_dst->write( numFrames );
+      m_dst->write( numBones );
+      if (compress)
+         m_dst->write( -offsetFrames );
+      else
+         m_dst->write( offsetFrames );
+      m_dst->write( numLODs );
+      m_dst->write( offsetLODs );
+      m_dst->write( numTags );
+      m_dst->write( offsetTags );
+   }
+   else
+   {
+#endif
    m_dst->write( magic[0] );
    m_dst->write( magic[1] );
    m_dst->write( magic[2] );
@@ -1936,6 +2375,9 @@
    m_dst->write( offsetFrames );
    m_dst->write( offsetTags );
    m_dst->write( offsetMeshes );
+#ifdef MDR_EXPORT
+   }
+#endif
 
    uint32_t endPos = m_dst->offset();
    m_dst->write( offsetEnd );
@@ -1961,7 +2403,7 @@
       if ( animInSection( getSafeName( a ), section ) 
             || (section == MS_Head && a == 0) )
       {
-         unsigned aFrameCount = m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, a );
+         unsigned aFrameCount = m_model->getAnimFrameCount( m_animationMode, a );
          if ( (aFrameCount == 0 && animCount == 1 )
                || (section == MS_Head) )
          {
@@ -1987,7 +2429,10 @@
                      {
                         int vertex = m_model->getTriangleVertex( *it, n );
                         double cords[3];
-                        m_model->getFrameAnimVertexCoords( a, t, vertex, cords[0], cords[1], cords[2] );
+                        if (m_animationMode == Model::ANIMMODE_SKELETAL)
+                           m_model->getVertexCoords(vertex, cords); // ZTM: FIXME: Get cords for this frame!
+                        else
+                           m_model->getFrameAnimVertexCoords( a, t, vertex, cords[0], cords[1], cords[2] );
                         dmax[0] = greater( dmax[0], cords[0] );
                         dmax[1] = greater( dmax[1], cords[1] );
                         dmax[2] = greater( dmax[2], cords[2] );
@@ -2026,13 +2471,104 @@
             }
             //log_debug( "Frame radius: %f\n", ( (float) radius ) );
             m_dst->write( (float) radius );
+#ifdef MDR_EXPORT // Compressed MDRs don't save frame name
+			if (type != MT_MDR || (type == MT_MDR && !compress))
+			{
+#endif
             char name[16] = "Misfit Model 3D"; // this is what other exporters do
             PORT_snprintf( name, sizeof(name), "%s%02d", animName.c_str(), t);
             m_dst->writeBytes( (uint8_t*) name, sizeof(name) );
+#ifdef MDR_EXPORT
+			}
+#endif
+
+#ifdef MDR_EXPORT
+            if (type == MT_MDR)
+            {
+               // Write MDR bones
+               for ( unsigned j = 0; j < bcount; j++ )
+               {
+                  if ( !boneJointInSection( m_model->getBoneJointName( j ), section ) )
+                     continue;
+
+                  Matrix rotMatrix;
+                  double rotVector[3];
+                  bool m_animationLoop = m_model->isAnimationLooping( m_animationMode, a );
+                  m_model->interpSkelAnimKeyframe( a, t, m_animationLoop, j, true, rotVector[0], rotVector[1], rotVector[2] );
+
+                  // origin
+                  double origin[4] = { 0, 0, 0, 1 };
+                  m_model->interpSkelAnimKeyframe( a, t, m_animationLoop, j, false, origin[0], origin[1], origin[2] );
+
+                  saveMatrix.apply( origin );
+
+                  if (compress)
+                  {
+					uint8_t data[24];
+
+                     // ZTM: TODO: Compressed MDR bone matrix and origin
+
+					m_dst->writeBytes( (uint8_t *)data, 24 );
+                  }
+                  else
+                  {
+                     // Seems whenver we have a nan its from a identity matrix
+                     if ( rotVector[0] != rotVector[0] || rotVector[1] != rotVector[1] || rotVector[2] != rotVector[2] )
+                     {
+                        // writeIdentity();
+                        size_t count = 0;
+                        float z = 0.0;
+                        float o = 1.0;
+                        for ( int i = 0; i < 3; i++ )
+                        {
+                           for ( int j = 0; j < 3; j++ )
+                           {
+                              if ( i == j )
+	                         {
+	                        	count += m_dst->write( o );
+	                         }
+	                         else
+	                         {
+	                        	count += m_dst->write( z );
+	                         }
+                           }
+
+                           m_dst->write( (float) origin[i] );
+                        }
+                     }
+                     else
+                     {
+                        rotMatrix.setRotation( rotVector );
+                        rotMatrix = rotMatrix*saveMatrix;
+
+                        // orientation and origin
+                        for ( int m = 0; m < 3; m++ )
+                        {
+                           for ( int n = 0; n < 3; n++ )
+                           {
+                              m_dst->write( (float) rotMatrix.get( m, n ) );
+                           }
+
+                           m_dst->write( (float) origin[m] );
+                        }
+                     }
+                  }
+               }
+            }
+#endif
          }
       }
    }
 
+#ifdef MDR_EXPORT
+   if (type == MT_MDR)
+   {
+      // Tags in MDR are done later.
+   }
+   else // MT_MD3
+   {
+#endif
+
    //TAGS
    log_debug( "writing tags at %d/%d\n", offsetTags, m_dst->offset() );
 
@@ -2100,9 +2636,318 @@
          }
       }
    }
+#ifdef MDR_EXPORT
+   }
+#endif
 
    vector<Model::Material *> & modelMaterials = getMaterialList( m_model );
 
+#ifdef MDR_EXPORT
+   if (type == MT_MDR)
+   {
+      // Write MDR LODs
+      log_debug( "writing LODs at %d/%d\n", offsetLODs, m_dst->offset() );
+#if 1
+      int32_t lodEndPos;
+      int32_t offsetEndLod = 0;
+
+      // Write LODs
+      for (int i = 0; i < numLODs; i++)
+      {
+         m_dst->write( (int32_t) numMeshes );
+         m_dst->write( (int32_t) MDR_LOD_SIZE ); // offset of the first mesh from this LOD
+         lodEndPos = m_dst->offset();
+         m_dst->write( (int32_t) offsetEndLod ); // offset of the next LOD from this LOD
+
+         for ( mlit = meshes.begin(); mlit != meshes.end(); mlit++ )
+         {
+            if ( (*mlit).group >= 0 && groupInSection( m_model->getGroupName( (*mlit).group ), section )
+				/* && groupInLOD( (*mlit).group ), i ) */)
+            {
+               log_debug( "writing mdr mesh header at %d\n", m_dst->offset() );
+
+               Mesh::VertexList::iterator vit;
+
+               // MESH HEADER
+               int8_t mMagic[4];
+               mMagic[0] = 'R';
+               mMagic[1] = 'D';
+               mMagic[2] = 'M';
+               mMagic[3] = '5';
+               char mName[MAX_QPATH];
+               memset( mName, 0, MAX_QPATH );
+               if ( PORT_snprintf( mName, sizeof( mName ), "%s", m_model->getGroupName( (*mlit).group ) ) > MAX_QPATH )
+               {
+                  log_error( "group name is too large\n" );
+                  m_model->setFilterSpecificError( transll( QT_TRANSLATE_NOOP( "LowLevel", "Group name is too large for MD3 export." ) ).c_str() );
+                  return Model::ERROR_FILTER_SPECIFIC;
+               }
+
+               const int TRI_SIZE = 3 * 4;
+               const int VERT_SIZE = 3 * 4 + 2 * 4 + 4; // Plus x * BONE_WEIGHT_SIZE
+               const int BONE_REF_SIZE = 4;
+               const int BONE_WEIGHT_SIZE = 4 * 5;
+
+               int32_t mNumVerts    = (*mlit).vertices.size();
+               int32_t mNumTris     = (*mlit).faces.size();
+               int32_t mNumBoneRefs = 0; // (unused by ioquake3)
+               int32_t mOffHeader   = 0-(m_dst->offset()); // this will be a negative number (unused by ioquake3)
+               int32_t mOffTris     = (10 * 4) + MAX_QPATH + MAX_QPATH; // size of mesh header
+               int32_t mOffVerts    = mOffTris + mNumTris * TRI_SIZE;
+               int32_t mOffBoneRefs = mOffVerts + mNumVerts * VERT_SIZE; // (unused by ioquake3)
+
+               // Add mdrWeight_t for each bone ref in vertex
+               for ( vit = (*mlit).vertices.begin(); vit != (*mlit).vertices.end(); vit++ )
+               {
+                  Model::InfluenceList ilist;
+
+				  m_model->getVertexInfluences( (*vit).v, ilist );
+
+                  mOffBoneRefs += ilist.size() * BONE_WEIGHT_SIZE;
+               }
+
+               int32_t mOffEnd      = mOffBoneRefs + mNumBoneRefs * BONE_REF_SIZE;
+
+               // write header
+               m_dst->write( mMagic[0] );
+               m_dst->write( mMagic[1] );
+               m_dst->write( mMagic[2] );
+               m_dst->write( mMagic[3] );
+               m_dst->writeBytes( (uint8_t*) mName, MAX_QPATH );
+               // SHADER
+               {
+                  int matId = m_model->getGroupTextureId( (*mlit).group );
+                  string matFileName;
+                  string matFullName;
+                  string matPath;
+                  string matBaseName;
+                  if ( matId != -1 )
+                  {
+                     Model::Material * mat = modelMaterials[matId];
+                     matFileName = mat->m_filename;
+                  }
+                  else
+                  {
+                     //Texture isn't set
+                     matFileName = mName;
+                     matFileName += ".tga";
+                  }
+
+                  char sName[MAX_QPATH];
+                  std::string spk3Path;
+                  memset( sName, 0, MAX_QPATH );
+
+                  if ( matId >= 0 )
+                  {
+                     spk3Path = materialToPath( matId );
+                     if ( !spk3Path.empty() 
+                           && spk3Path[spk3Path.size() - 1] != '/' 
+                           && spk3Path.size() < ( MAX_QPATH+1 ) )
+                     {
+                        spk3Path += "/";
+                     }
+                  }
+
+                  normalizePath( matFileName.c_str(), matFullName, matPath, matBaseName );
+
+                  log_debug( "comparing %s and %s\n", matFullName.c_str(), m_modelPath.c_str() );
+                  if ( strncmp( matFullName.c_str(), m_modelPath.c_str(), m_modelPath.size() ) == 0)
+                  {
+                     log_debug( "path is common, using MD3_PATH\n" );
+                     // model path is the same as texture file path, remove model
+                     // path and prepend MD3_PATH
+                     if ( PORT_snprintf( sName, sizeof( sName ), "%s%s",
+                              spk3Path.c_str(), matBaseName.c_str() ) >= MAX_QPATH )
+                     {
+                        log_error( "MD3_PATH+texture_filename is to long.\n" );
+                        m_model->setFilterSpecificError( transll( QT_TRANSLATE_NOOP( "LowLevel", "Texture filename is too long." ) ).c_str() );
+                        return Model::ERROR_FILTER_SPECIFIC;
+                     }
+                  }
+                  else if ( pathIsAbsolute( matFileName.c_str() ) )
+                  {
+                     log_debug( "path is not common, but is absolute\n" );
+                     // model path is not the same as texture file path, try to
+                     // remove pk3 path from model and try again
+                     std::string common;
+                     common = m_modelPath;
+
+                     // default to PK3 Path
+                     PORT_snprintf( sName, sizeof( sName ), "%s%s",
+                           spk3Path.c_str(), matBaseName.c_str() );
+                  }
+                  else
+                  {
+                     log_debug( "path is relative, using as-is\n" );
+                     // relative path... sounds like a fallback, just use 
+                     // matFileName as is
+                     PORT_snprintf( sName, sizeof(sName), "%s", matFileName.c_str() );
+                  }
+                  log_debug( "writing texture path: %s\n", sName );
+
+                  m_dst->writeBytes( (uint8_t*) sName, MAX_QPATH );
+                  m_dst->write( (int32_t)0 ); // shaderIndex - for ingame use
+               }
+               m_dst->write( mOffHeader ); 
+               m_dst->write( mNumVerts );
+               m_dst->write( mOffVerts );
+               m_dst->write( mNumTris );
+               m_dst->write( mOffTris );
+               m_dst->write( mNumBoneRefs );
+               m_dst->write( mOffBoneRefs );
+               m_dst->write( mOffEnd );
+
+               // TRIANGLES (Same as MD3)
+               Mesh::FaceList::iterator fit;
+               for ( fit = (*mlit).faces.begin(); fit != (*mlit).faces.end(); fit++ )
+               {
+                  for ( int j = 2; j >= 0; j-- )
+                  {
+                     m_dst->write( (*fit).v[j] );
+                  }
+               }
+
+               // VERTEX
+               Matrix saveMatrix = getMatrixFromPoint( -1, -1, rootTag ).getInverse();
+
+               m_model->calculateNormals();
+
+               for ( vit = (*mlit).vertices.begin(); vit != (*mlit).vertices.end(); vit++ )
+               {
+                  double meshVec[4] = {0,0,0,1};
+                  double meshNor[4] = {0,0,0,1};
+
+                  m_model->getVertexCoords( (*vit).v, meshVec );
+
+                  // NORMAL
+                  float meshNorF[3];
+                  if ( getVertexNormal( m_model, (*mlit).group, (*vit).v, meshNorF ) )
+                  {
+                      meshNor[0] = meshNorF[0];
+                      meshNor[1] = meshNorF[1];
+                      meshNor[2] = meshNorF[2];
+                  }
+
+                  saveMatrix.apply( meshVec );
+                  saveMatrix.apply( meshNor );
+
+                  m_dst->write( (float) meshNor[0] );
+                  m_dst->write( (float) meshNor[1] );
+                  m_dst->write( (float) meshNor[2] );
+
+                  // TEXT COORDS
+                  m_dst->write( (*vit).uv[0] );
+                  m_dst->write( (float) (1.0f - (*vit).uv[1]) );
+
+                  // WEIGHTS
+                  Model::InfluenceList ilist;
+                  Model::InfluenceList::iterator it;
+
+				  m_model->getVertexInfluences( (*vit).v, ilist );
+
+                  int32_t numWeights = ilist.size();
+                  m_dst->write( numWeights );
+
+                  // ZTM: FIXME: I have no idea if this is right
+                  for ( it = ilist.begin(); it != ilist.end(); it++ )
+                  {
+                     float     boneWeight = 1.0f / numWeights; //(*it).m_weight;
+                     float     offset[3] = {0.0f, 0.0f, 10.0f};
+                     // MD4: offset gives the direction vector of the weight's influence.
+
+// VectorLength
+#define Length(v) (sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]))
+
+/*
+            // get the bone scaling
+            tm = bone->GetNodeTM( interfaceptr->GetTime() );
+
+            // scale the offset and store it in our vertex
+            p = v->GetOffsetVector( i );
+            offset[ 0 ] = p.x * Length( tm.GetRow( 0 ) );
+            offset[ 1 ] = p.y * Length( tm.GetRow( 1 ) );
+            offset[ 2 ] = p.z * Length( tm.GetRow( 2 ) );
+
+// GetOffsetVector() will return the coordinates of the vertex
+// in the local coordinates of associated INode pointer from GetNode
+// this is NOT THE SAME as the .vph file coordinates. (It is simpler)
+// the world coordinates of the vertex have been transformed by the Inverse of the INode pointer.
+*/
+
+                     Matrix rotMatrix;
+                     double forward[3], right[3], up[3];
+
+                     m_model->getBoneJointFinalMatrix((*it).m_boneId, rotMatrix);
+                     rotMatrix = rotMatrix*saveMatrix;
+
+                     forward[0] = rotMatrix.get(0,0);
+                     forward[1] = rotMatrix.get(0,1);
+                     forward[2] = rotMatrix.get(0,2);
+
+                     right[0] = rotMatrix.get(1,0);
+                     right[1] = rotMatrix.get(1,1);
+                     right[2] = rotMatrix.get(1,2);
+
+                     up[0] = rotMatrix.get(2,0);
+                     up[1] = rotMatrix.get(2,1);
+                     up[2] = rotMatrix.get(2,2);
+
+                     Matrix InvMatrix;
+                     Vector offsetVec;
+
+                     InvMatrix = rotMatrix.getInverse();
+                     offsetVec.setAll(meshVec);
+                     offsetVec.transform3(InvMatrix);
+
+                     offset[0] = offsetVec[0] * Length(forward);
+                     offset[1] = offsetVec[1] * Length(right);
+                     offset[2] = offsetVec[2] * Length(up);
+
+                     //log_debug("offset=%f,%f,%f\n", offset[0], offset[1], offset[2]);
+
+                     m_dst->write( (int32_t) bonesRemap[(*it).m_boneId] );
+                     m_dst->write( boneWeight );
+                     m_dst->write( offset[0] );
+                     m_dst->write( offset[1] );
+                     m_dst->write( offset[2] );
+                  }
+               }
+            }
+         }
+
+         // Go fix offsetEndLod
+         offsetEndLod = m_dst->offset() - offsetLODs;
+         m_dst->seek( lodEndPos );
+         m_dst->write( offsetEndLod );
+         m_dst->seek( (offsetLODs+offsetEndLod) );
+
+         offsetLODs = offsetEndLod; // for next LOD
+      }
+
+      // ZTM: TODO: Should offsetTags be set at the begining?
+      // Add size of meshes
+      offsetTags += m_dst->offset() - offsetMeshes;
+
+      // Go back and fix offsetTags
+      uint32_t tagPos = endPos-4;
+      m_dst->seek( tagPos );
+      m_dst->write( offsetTags );
+
+      // Now go write the tags!
+      m_dst->seek( offsetTags );
+#else // Below is what needs to be done.
+      //for each LOD
+         // write the number of surfaces (Meshes) (numSurfaces),
+         // offset of the first surfaces (Meshes) (offsetSurfaces),
+         // and the offset of the next LOD (offsetEnd)
+
+         // Write surface (Mesh)
+      // end LODs
+#endif
+   }
+   else // MT_MD3
+   {
+#endif
    // MESHES
    log_debug( "writing meshes at %d/%d\n", offsetMeshes, m_dst->offset() );
 
@@ -2135,7 +2980,7 @@
          int32_t mNumShaders  = 1;
          int32_t mNumVerts    = (*mlit).vertices.size();
          int32_t mNumTris     = (*mlit).faces.size();
-         int32_t mOffTris     = HEADER_SIZE;
+         int32_t mOffTris     = MD3_HEADER_SIZE;
          int32_t mOffShaders  = mOffTris + mNumTris * TRI_SIZE;
          int32_t mOffST       = mOffShaders + mNumShaders * SHADER_SIZE;
          int32_t mOffVerts    = mOffST + mNumVerts * TEXCOORD_SIZE;
@@ -2345,7 +3190,40 @@
          }
       }
    }
+#ifdef MDR_EXPORT
+   }
 
+   if (type == MT_MDR)
+   {
+      //TAGS
+      log_debug( "writing tags at %d/%d\n", offsetTags, m_dst->offset() );
+
+      // Tags in MDR are simple (bone index and name)
+      for ( unsigned j = 0; j < pcount; j++ )
+      {
+         if ( tagInSection( m_model->getPointName( j ), section ) )
+         {
+            int32_t boneIndex = bonesRemap[m_model->getPointBoneJoint(j)];
+			m_dst->write(boneIndex);
+
+            char tName[32];
+            memset( tName, 0, sizeof( tName ) );
+            if ( PORT_snprintf( tName, sizeof( tName ), "%s", m_model->getPointName( j ) ) >= (int)sizeof( tName ) )
+            {
+               log_error( "Point name is to long.\n" );
+               m_model->setFilterSpecificError( transll( QT_TRANSLATE_NOOP( "LowLevel", "Point name is too long." ) ).c_str() );
+               return Model::ERROR_FILTER_SPECIFIC;
+            }
+            m_dst->writeBytes( (uint8_t*) tName, MAX_QPATH );
+         }
+      }
+   }
+   else // MT_MD3
+   {
+      // Tags are done already.
+   }
+#endif
+
    offsetEnd = m_dst->offset();
    m_dst->seek( endPos );
    m_dst->write( offsetEnd );
@@ -2353,38 +3231,78 @@
    return Model::ERROR_NONE;
 }
 
+bool Md3Filter::animSyncWarning(std::string name)
+{
+   for (unsigned i = 0; s_animSyncWarning[i] != NULL; i++)
+   {
+      if (strncasecmp(s_animSyncWarning[i], name.c_str(), name.length()) == 0)
+      {
+         return true;
+      }
+   }
+   return false;
+}
+
 bool Md3Filter::writeAnimations()
 {
    string animFile = m_modelPath + "/animation.cfg";
    FILE * fp = fopen( animFile.c_str(), "w" );
+   bool eliteLoop = false;
+   bool animKeyword = false;
 
    if ( fp != NULL )
    {
       log_debug( "writing animation.cfg\n" );
 
-      fprintf( fp, "// animation config file\r\n\r\n" );
+      fprintf( fp, "// animation config file\r\n" );
 
-      char value[30];
-      if ( m_model->getMetaData( "MD3_sex", value, sizeof(value) ) )
+      bool hadKeyword = false;
+      char keyword[1024], value[1024];
+
+      for (unsigned int i = 0; i < m_model->getMetaDataCount(); i++)
       {
-         fprintf( fp, "sex %s\r\n", value );
+         if (!m_model->getMetaData(i, keyword, sizeof (keyword), value, sizeof (value)))
+            continue;
+
+         if (strncasecmp(keyword, "MD3_CFG_", 8) == 0)
+         {
+            if (!hadKeyword)
+            {
+               hadKeyword = true;
+               fprintf( fp, "\r\n" );
+            }
+            if (strlen(value) > 0)
+               fprintf( fp, "%s %s\r\n", &keyword[8], value );
+            else
+               fprintf( fp, "%s\r\n", &keyword[8] );
+         }
+         // Support old keywords
+	 	 else if (strncasecmp(keyword, "MD3_sex", 7) == 0
+           || strncasecmp(keyword, "MD3_footsteps", 13) == 0
+           || strncasecmp(keyword, "MD3_headoffset", 14) == 0
+           || strncasecmp(keyword, "MD3_fixedtorso", 14) == 0
+           || strncasecmp(keyword, "MD3_fixedlegs", 13) == 0)
+         {
+            if (!hadKeyword)
+            {
+               hadKeyword = true;
+               fprintf( fp, "\r\n" );
+            }
+            if (strlen(value) > 0)
+               fprintf( fp, "%s %s\r\n", &keyword[4], value );
+            else
+               fprintf( fp, "%s\r\n", &keyword[4] );
+         }
+         // animations.cfg format settings
+         else if (strncasecmp(keyword, "MD3_EliteLoop", 13) == 0)
+         {
+            eliteLoop = (atoi(value) > 0);
+         }
+         else if (strncasecmp(keyword, "MD3_AnimKeyword", 15) == 0)
+         {
+            animKeyword = (atoi(value) > 0);
+         }
       }
-      if ( m_model->getMetaData( "MD3_footsteps", value, sizeof(value) ) )
-      {
-         fprintf( fp, "footsteps %s\r\n", value );
-      }
-      if ( m_model->getMetaData( "MD3_headoffset", value, sizeof(value) ) )
-      {
-         fprintf( fp, "headoffset %s\r\n", value );
-      }
-      if ( m_model->getMetaData( "MD3_fixedtorso", value, sizeof(value) ) )
-      {
-         fprintf( fp, "fixedtorso %s\r\n", value );
-      }
-      if ( m_model->getMetaData( "MD3_fixedlegs", value, sizeof(value) ) )
-      {
-         fprintf( fp, "fixedlegs %s\r\n", value );
-      }
 
       fprintf( fp, "\r\n" );
 
@@ -2392,33 +3310,63 @@
       fprintf( fp, "//    first   count   looping   fps\r\n\r\n" );
 
       char warning[] = " (MUST NOT CHANGE -- hand animation is synced to this)";
-      for ( int anim = 0; anim < MD3_ANIMATIONS; anim++ )
+      size_t animCount = m_model->getAnimCount( m_animationMode );
+      for ( size_t anim = 0; anim < animCount; anim++ )
       {
-         int animIndex = 0;
          int animFrame = 0;
          int count = 1;
          int fps   = 15;
-         getExportAnimData( anim, animIndex, animFrame, count, fps );
 
+         if (!getExportAnimData( (int)anim, animFrame, count, fps ))
+         {
+            continue;
+         }
+
          int loop = count; // loop by default
 
+         std::string name = getSafeName( anim );
+		 size_t len = name.length();
+         for ( size_t n = 0; n < len; n++ )
+         {
+            name[n] = std::toupper(name[n]);
+         }
+
          // disable looping on non-looping anims
-         if ( count <= 1 || s_animLoop[anim] == 0 )
+         if ( count <= 1 || !m_model->isAnimationLooping( m_animationMode, anim ) )
          {
             loop = 0;
          }
 
-         char name[30];
-         strcpy( name, s_animNames[anim] );
-         size_t len = strlen( name );
-         for ( size_t n = 0; n < len; n++ )
+         // Convert to Elite Force Single Player Style
+         if (eliteLoop)
          {
-            name[n] = toupper( name[n] );
+            if (loop == 0)
+               loop = -1; // No loop
+            else
+               loop = 0; // Loop
          }
 
-         fprintf( fp, "%d\t%d\t%d\t%d\t\t// %s%s\r\n", 
-               animFrame, count, loop, fps, name,
-               (s_animSyncWarning[anim] ? warning : "") );
+         if (animKeyword)
+         {
+            // Aline animFrame
+            char spaces[23] = {' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','\0','\0'};
+            int numSpaces = (20 - name.length() > 0) ? (20 - name.length()) : 0;
+
+            spaces[numSpaces] = spaces[numSpaces+1] = '\0';
+
+            if (animSyncWarning(name))
+               fprintf( fp, "%s%s\t%d\t%d\t%d\t%d\t\t// %s\r\n", 
+                     name.c_str(), spaces, animFrame, count, loop, fps, warning );
+            else
+               fprintf( fp, "%s%s\t%d\t%d\t%d\t%d\r\n", 
+                     name.c_str(), spaces, animFrame, count, loop, fps );
+         }
+         else
+         {
+            fprintf( fp, "%d\t%d\t%d\t%d\t\t// %s%s\r\n", 
+                  animFrame, count, loop, fps, name.c_str(),
+                  (animSyncWarning(name) ? warning : "") );
+         }
       }
       fclose( fp );
       return true;
@@ -2458,54 +3406,80 @@
    return m;
 }
 
-void Md3Filter::getExportAnimData( int fileAnim, int & modelAnim, 
+bool Md3Filter::getExportAnimData( int modelAnim,
       int & fileFrame, int & frameCount, int & fps )
 {
    fileFrame  = 0;
    frameCount = 0;
 
-   size_t animCount = m_model->getAnimCount( Model::ANIMMODE_FRAME );
+   size_t animCount = m_model->getAnimCount( m_animationMode );
+   MeshSectionE section = MS_None;
+   std::string animName = getSafeName( modelAnim );
 
+   if (strncasecmp(animName.c_str(), "torso_", 6) == 0)
+   {
+      section = MS_Upper;
+   }
+   else if (strncasecmp(animName.c_str(), "legs_", 5) == 0)
+   {
+      section = MS_Lower;
+   }
+
+   // If this is a "dead" animation and its after a "death" animation
+   //   and it has 0 frames, use the last frame of the death animation.
+   if (modelAnim > 0 && strncasecmp(animName.c_str(), "both_dead", 9) == 0
+      && strncasecmp(getSafeName( modelAnim - 1 ).c_str(), "both_death", 10) == 0
+      && m_model->getAnimFrameCount( m_animationMode, modelAnim ) == 0 )
+   {
+      if (getExportAnimData( modelAnim - 1, fileFrame, frameCount, fps ))
+      {
+         fileFrame += frameCount - 1;
+         frameCount = 1;
+         return true;
+      }
+   }
+
    for ( size_t a = 0; a < animCount; a++ )
    {
       std::string name = getSafeName( a );
       if ( animInSection( name, MS_Upper )
             || animInSection( name, MS_Lower ) )
       {
-         if ( strcasecmp( s_animNames[ fileAnim ], name.c_str() ) == 0 )
+         if ( a == (size_t)modelAnim )
          {
-            frameCount = m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, a );
-            fps   = (int) m_model->getAnimFPS( Model::ANIMMODE_FRAME, a );
+            frameCount = m_model->getAnimFrameCount( m_animationMode, a );
+            fps   = (int) m_model->getAnimFPS( m_animationMode, a );
 
             if ( fps <= 0 ) // just being paranoid
             {
                fps = 15;
             }
 
-            return;
+			if (section == MS_Lower)
+			{
+				// Must still count torso animations after this for fileFrame
+			}
+			else
+			{
+			   return true;
+			}
          }
-         else
+         // All torso frames from go before leg frames, all legs go after tosro
+         else if (section == MS_None || (section == MS_Lower && (a < (size_t)modelAnim || strncasecmp(name.c_str(), "legs_", 5) != 0))
+            || (section == MS_Upper && strncasecmp(name.c_str(), "legs_", 5) != 0))
          {
-            fileFrame += m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, a );
+            fileFrame += m_model->getAnimFrameCount( m_animationMode, a );
          }
       }
    }
 
-   // if this is a "dead" animation and there isn't a "dead" animation, try the
-   // last frame of the "death" animation.
-   if ( fileAnim < 6 && (fileAnim % 2) == 1 )
+   if (section == MS_Lower && frameCount)
    {
-      fileAnim--;
-      getExportAnimData( fileAnim, modelAnim, fileFrame, frameCount, fps );
-      if ( modelAnim >= 0 )
-      {
-         fileFrame += frameCount - 1;
-         frameCount = 1;
-         return;
-      }
+      // Finished adding up fileFrame for legs animations
+      return true;
    }
 
-   modelAnim = -1;
+   return false;
 }
 
 size_t Md3Filter::writeIdentity()
@@ -2672,7 +3646,12 @@
    log_debug( "isSupported( %s )\n", filename );
    unsigned len = strlen( filename );
 
+#ifdef MDR_GENERAL
+   if ( len >= 4 && ( strcasecmp( &filename[len-4], ".md3" ) == 0
+		|| strcasecmp( &filename[len-4], ".mdr" ) == 0 ) )
+#else
    if ( len >= 4 && strcasecmp( &filename[len-4], ".md3" ) == 0 )
+#endif
    {
       log_debug( "  true\n" );
       return true;
@@ -2688,6 +3667,9 @@
 {
    list<string> rval;
    rval.push_back( "*.md3" );
+#ifdef MDR_LOAD
+   rval.push_back( "*.mdr" );
+#endif
    return rval;
 }
 
@@ -2695,6 +3677,9 @@
 {
    list<string> rval;
    rval.push_back( "*.md3" );
+#ifdef MDR_EXPORT
+   rval.push_back( "*.mdr" );
+#endif
    return rval;
 }
 
Index: src/libmm3d/modelundo.cc
===================================================================
--- src/libmm3d/modelundo.cc	(revision 440)
+++ src/libmm3d/modelundo.cc	(working copy)
@@ -2441,6 +2441,60 @@
    m_oldFPS     = oldFps;
 }
 
+MU_SetAnimLoop::MU_SetAnimLoop()
+{
+}
+
+MU_SetAnimLoop::~MU_SetAnimLoop()
+{
+}
+
+void MU_SetAnimLoop::undo( Model * model )
+{
+   model->setAnimationLooping( m_mode, m_animNum, m_oldLoop );
+   if ( model->getAnimationMode() != Model::ANIMMODE_NONE && (model->getAnimationMode() != m_mode || model->getCurrentAnimation() != m_animNum) ) 
+   {
+      model->setCurrentAnimation( m_mode, m_animNum );
+   }
+}
+
+void MU_SetAnimLoop::redo( Model * model )
+{
+   model->setAnimationLooping( m_mode, m_animNum, m_newLoop );
+   if ( model->getAnimationMode() != Model::ANIMMODE_NONE && (model->getAnimationMode() != m_mode || model->getCurrentAnimation() != m_animNum) ) 
+   {
+      model->setCurrentAnimation( m_mode, m_animNum );
+   }
+}
+
+bool MU_SetAnimLoop::combine( Undo * u )
+{
+   MU_SetAnimLoop * undo = dynamic_cast< MU_SetAnimLoop * >( u );
+
+   if ( undo && undo->m_mode == m_mode && undo->m_animNum == m_animNum )
+   {
+      m_newLoop = undo->m_newLoop;
+      return true;
+   }
+   else
+   {
+      return false;
+   }
+}
+
+unsigned MU_SetAnimLoop::size()
+{
+   return sizeof(MU_SetAnimLoop);
+}
+
+void MU_SetAnimLoop::setAnimLoop( Model::AnimationModeE mode, unsigned animNum, bool newLoop, bool oldLoop )
+{
+   m_mode       = mode;
+   m_animNum    = animNum;
+   m_newLoop    = newLoop;
+   m_oldLoop    = oldLoop;
+}
+
 MU_SetAnimKeyframe::MU_SetAnimKeyframe()
 {
 }
Index: src/libmm3d/model.h
===================================================================
--- src/libmm3d/model.h	(revision 440)
+++ src/libmm3d/model.h	(working copy)
@@ -651,6 +651,7 @@
             JointKeyframeList m_jointKeyframes;
             double   m_fps;  // Frames per second
             double   m_spf;  // Seconds per frame (for convenience, 1.0 / m_fps)
+            bool     m_animationLoop;
             unsigned m_frameCount;    // Number of frames in the animation
             bool     m_validNormals;  // Whether or not the normals have been calculated for the current animation frame
 
@@ -766,6 +767,7 @@
             FrameAnimDataList m_frameData;
 
             double m_fps;  // Frames per second
+            bool   m_animationLoop;
             bool   m_validNormals;  // Whether or not the normals have been calculated
 
             bool propEqual( const FrameAnim & rhs, int propBits = PropAll, double tolerance = 0.00001 ) const;
@@ -1109,8 +1111,8 @@
       unsigned getCurrentAnimationFrame() const;
       double   getCurrentAnimationTime() const;
 
-      void setAnimationLooping( bool o );
-      bool isAnimationLooping() const;
+      void setAnimationLooping( AnimationModeE mode, unsigned anim, bool loop );
+      bool isAnimationLooping( AnimationModeE mode, unsigned anim ) const;
 
       // Stop animation mode, go back to standard pose editing.
       void setNoAnimation();
@@ -1868,7 +1870,6 @@
       int    m_numFrames;  // Deprecated
 
       AnimationModeE m_animationMode;
-      bool     m_animationLoop;
       unsigned m_currentFrame;
       unsigned m_currentAnim;
       double   m_currentTime;
Index: src/libmm3d/modelundo.h
===================================================================
--- src/libmm3d/modelundo.h	(revision 440)
+++ src/libmm3d/modelundo.h	(working copy)
@@ -1069,6 +1069,29 @@
       double   m_oldFPS;
 };
 
+class MU_SetAnimLoop : public ModelUndo
+{
+   public:
+
+      MU_SetAnimLoop();
+      virtual ~MU_SetAnimLoop();
+
+      void undo( Model * );
+      void redo( Model * );
+      bool combine( Undo * );
+
+      unsigned size();
+
+      void setAnimLoop( Model::AnimationModeE mode, unsigned animNum, bool newLoop, bool oldLoop );
+
+   private:
+
+      Model::AnimationModeE m_mode;
+      unsigned m_animNum;
+      bool   m_newLoop;
+      bool   m_oldLoop;
+};
+
 class MU_SetAnimKeyframe : public ModelUndo
 {
    public:
Index: src/implui/animexportwin.cc
===================================================================
--- src/implui/animexportwin.cc	(revision 440)
+++ src/implui/animexportwin.cc	(working copy)
@@ -268,7 +268,6 @@
 
       bool enable = m_model->setUndoEnabled( false );
 
-      m_model->setAnimationLooping( true );
       m_model->setCurrentAnimation( mode, a );
 
       int frameNum = 0;
Index: src/implui/animwidget.h
===================================================================
--- src/implui/animwidget.h	(revision 440)
+++ src/implui/animwidget.h	(working copy)
@@ -84,7 +84,6 @@
       void insertAnimationNames();
 
       Model  * m_model;
-      bool     m_doLoop;
       bool     m_playing;
       double   m_timeInterval;
       double   m_currentTime;
Index: src/implui/animwidget.cc
===================================================================
--- src/implui/animwidget.cc	(revision 440)
+++ src/implui/animwidget.cc	(working copy)
@@ -86,7 +86,6 @@
 AnimWidget::AnimWidget( Model * model, bool isUndo, QWidget * parent )
    : QWidget( parent ),
      m_model( model ),
-     m_doLoop( true ),
      m_playing( false ),
      m_undoing( isUndo ),
      m_ignoreChange( false )
@@ -116,8 +115,7 @@
 
    m_countSlider->setTickPosition( QSlider::TicksBelow );
 
-   m_doLoop = m_model->isAnimationLooping();
-   m_loop->setChecked( m_doLoop );
+   m_loop->setChecked( m_model->isAnimationLooping(m_model->getAnimationMode(), m_model->getCurrentAnimation()) );
 
    m_skelAnimCount = m_model->getAnimCount( Model::ANIMMODE_SKELETAL );
    m_frameAnimCount = m_model->getAnimCount( Model::ANIMMODE_FRAME );
@@ -520,10 +518,15 @@
 
 void AnimWidget::loopToggled( bool o )
 {
-   m_doLoop = o;
-   m_model->setAnimationLooping( o );
-   m_model->setCurrentAnimationFrame( m_countSlider->value() - 1 );
-   DecalManager::getInstance()->modelUpdated( m_model );
+   if ( !m_ignoreChange && m_animCount > 0 )
+   {
+      log_debug( "toggling loop\n" );
+      m_model->setAnimationLooping( m_mode, indexToAnim( m_animName->currentIndex() ), o );
+      m_model->operationComplete( tr( "Set Looping", "Looping, operation complete" ).toUtf8() );
+
+      m_model->setCurrentAnimationFrame( m_countSlider->value() - 1 );
+      DecalManager::getInstance()->modelUpdated( m_model );
+   }
 }
 
 void AnimWidget::doPlay()
@@ -680,6 +683,7 @@
          m_ignoreChange = true;  // Qt alerts us even if we're responsible
          m_frameCount->setValue( count );
          m_fps->setText( QString::number(m_model->getAnimFPS( mode, index ) ) );
+         m_loop->setChecked( m_model->isAnimationLooping( mode, index ) );
          m_ignoreChange = false;
 
          m_countSlider->setMinimum( 1 );
@@ -703,6 +707,7 @@
          m_loop->setEnabled( false );
 
          m_fps->setText( QString("0") );
+         m_loop->setChecked( false );
          m_ignoreChange = true;  // Qt alerts us even if we're responsible
          m_frameCount->setValue( 0 );
          m_ignoreChange = false;
@@ -745,6 +750,7 @@
          m_loop->setEnabled( false );
 
          m_fps->setText( QString("0") );
+         m_loop->setChecked( false );
          m_ignoreChange = true;  // Qt alerts us even if we're responsible
          m_frameCount->setValue( 0 );
          m_ignoreChange = false;
