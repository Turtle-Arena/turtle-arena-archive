Index: src/libmm3d/md3filter.h
===================================================================
--- src/libmm3d/md3filter.h	(revision 440)
+++ src/libmm3d/md3filter.h	(working copy)
@@ -28,6 +28,26 @@
 #ifndef __MD3FILTER_H
 #define __MD3FILTER_H
 
+//#define MISSIONPACK // Enable Quake III: Team Arena Support, fully compatible with Q3.
+#define TMNT // Enable special support my yet-to-be released Q3 mod, TMNT Arena, that should not be in mm3d :(
+#define MD3_GENERAL // "General" support for Team Arena and Smokin' Guns (and maybe other mods), it doesn't hurt Quake3 support.
+// Turtle Man: TODO: Finish moving unfinished MDR stuff from plugin to here.
+#define MDR_LOAD // Unfinished
+#define MDR_EXPORT // Unfinished
+#if defined MDR_LOAD || defined MDR_EXPORT
+#define MDR_GENERAL // Stuff for load and export
+
+//#define MDR_IDENT	(('5'<<24)+('M'<<16)+('D'<<8)+'R')
+#define MDR_VERSION	2
+//#define	MDR_MAX_BONES	128 // Not used in MDR loading in ioquake3 ?
+#endif
+
+#ifdef MD3_GENERAL
+#define MAX_DATAFIELD (128) // Max lenght of MD3 animations cfg "metadata" to save
+// "footsteps" "headoffset" "sex"
+// This number is not connected to the MD3 format.
+#endif
+
 #define MD3_VERSION 15
 #define MAX_QPATH 64
 #define MD3_MAX_FRAMES 1024
@@ -73,6 +93,16 @@
 
    protected:
 
+#ifdef MDR_GENERAL
+      typedef enum _MeshType_e
+      {
+         MT_None = -1,
+         MT_MD3 = 0,
+         MT_MDR,
+         MT_MAX
+      } MeshTypeE;
+#endif
+
       typedef enum _MeshSection_e
       {
          MS_None = -1,
@@ -100,18 +130,27 @@
 
       typedef struct _Md3FileData_t
       {
+#ifdef MDR_GENERAL
+         MeshTypeE type; // MD3 or MDR
+#endif
          MeshSectionE section;
          string modelBaseName;
          string modelFile;
          string tag;
          int32_t tagPoint;
          DataSource * src;
-         int32_t offsetMeshes;
-         int32_t numMeshes;
+         int32_t offsetMeshes; // MD3 only
+         int32_t numMeshes; // MD3 only
          int32_t offsetTags;
          int32_t numTags;
          int32_t numFrames;
-         MeshVectorInfoT ** meshVecInfos;
+         MeshVectorInfoT ** meshVecInfos; // MD3 only
+#ifdef MDR_GENERAL
+         // Only used by MDR
+         int32_t numBones;
+         int32_t numLODs;
+         int32_t offsetLODs;
+#endif
       } Md3FileDataT;
       typedef std::list< Md3FileDataT > Md3FileDataList;
 
@@ -123,6 +162,19 @@
       } Md3PathT;
       typedef std::vector< Md3PathT > Md3PathList;
 
+#ifdef MDR_GENERAL
+      typedef struct _MdrAnimation_t
+      {
+         std::string name;
+         bool loop;
+      } MdrAnimationT;
+      typedef std::vector< MdrAnimationT > MdrAnimatoinList;
+
+      typedef struct {
+      	float		matrix[3][4];
+      } mdrBone_t;
+#endif
+
       unsigned readString( char * dest, size_t len );
 
       bool     readAnimations( bool create );
@@ -138,8 +190,8 @@
       // Returns MD3 frame number for a specific animation frame
       int      animToFrame( MeshSectionE section, int anim, int frame );
 
-      // Indicates if the animation specified is contained in the 
-      // specified MD3 model section 
+      // Indicates if the animation specified is contained in the
+      // specified MD3 model section
       bool     animInSection( std::string animName, MeshSectionE section );
       bool     groupInSection( std::string animName, MeshSectionE section );
       bool     tagInSection( std::string animName, MeshSectionE section );
@@ -165,6 +217,10 @@
 
       //writes
       Model::ModelErrorE writeSectionFile( const char * filename, MeshSectionE section, MeshList & meshes );
+#ifdef MD3_GENERAL
+      bool AnimLoop(std::string name);
+      bool AnimSyncWarning(std::string name);
+#endif
       bool     writeAnimations();
       size_t   writeIdentity();
       DataDest * m_dst;
@@ -174,8 +230,13 @@
       double   greater(double a, double b);
       double   smaller(double a, double b);
       Matrix   getMatrixFromPoint( int anim, int frame, int point );
-      void getExportAnimData( int fileAnim, int & modelAnim, 
+#ifdef MD3_GENERAL
+      bool getExportAnimData( int modelAnim,
             int & fileFrame, int & frameCount, int & fps );
+#else
+      void getExportAnimData( int fileAnim, int & modelAnim,
+            int & fileFrame, int & frameCount, int & fps );
+#endif
 
 };
 #endif // __MD3FILTER_H
Index: src/libmm3d/md3filter.cc
===================================================================
--- src/libmm3d/md3filter.cc	(revision 440)
+++ src/libmm3d/md3filter.cc	(working copy)
@@ -61,14 +61,30 @@
 static Md3Filter * s_filter = NULL;
 #endif // PLUGIN
 
+#ifdef MISSIONPACK
+const int MD3_ANIMATIONS = 31;	// 31 animations in Team Arena players.
+const int MD3_Q3_ANIMATIONS = 25; // Quake 3 only uses the first 25
+#else
 const int MD3_ANIMATIONS = 25;
+#endif
 
 const int HEADER_SIZE = (11 * 4) + MAX_QPATH;
 const int FRAME_SIZE = ( 3 * ( 3 * 4 ) + 4 + 16 );
 const int TAG_SIZE = ( MAX_QPATH + ( 4 * 3 ) + ( 3 * 4 * 3 ) );
+#ifdef MDR_GENERAL
+const int MDR_HEADER_SIZE = (10 * 4) + MAX_QPATH;
+const int MDR_FRAME_SIZE = ( 3 * ( 3 * 4 ) + 4 + 16 ); // NOTE: must add (numBones * sizeof (mdrbone_t))
+const int MDR_BONE_SIZE = (4 * 3 * 4); // TODO: Check num : sizeof (Md3Filter::mdrBone_t);
+const int MDR_LOD_SIZE = (4 + 4 + 4);
+//const int MDR_TAG_SIZE = 32 + 4; // unused?
+#endif
 
 
-const char s_animNames[ MD3_ANIMATIONS ][16] = 
+#ifdef MISSIONPACK
+const char s_animNames[ MD3_ANIMATIONS ][18] =
+#else
+const char s_animNames[ MD3_ANIMATIONS ][16] =
+#endif
 {
    "both_death1",
    "both_dead1",
@@ -95,10 +111,34 @@
    "legs_idle",
    "legs_idlecr",
    "legs_turn",
+#ifdef MISSIONPACK
+   "torso_getflag",
+   "torso_guardbase",
+   "torso_patrol",
+   "torso_followme",
+   "torso_affirmative",
+   "torso_negative",
+#endif
 };
 
-int s_animLoop[ MD3_ANIMATIONS ] = 
+#ifdef MD3_GENERAL
+const char *s_animLoop[] =
 {
+   "torso_stand",
+   "torso_stand2",
+   "legs_walkcr",
+   "legs_walk",
+   "legs_run",
+   "legs_back",
+   "legs_swim",
+   "legs_idle",
+   "legs_idlecr",
+   "legs_turn",
+   NULL
+};
+#else
+int s_animLoop[ MD3_ANIMATIONS ] =
+{
    0, // both_death1
    0, // both_dead1
    0, // both_death2
@@ -124,10 +164,29 @@
    1, // legs_idle
    1, // legs_idlecr
    1, // legs_turn
+#ifdef MISSIONPACK
+   0, // torso_getflag
+   0, // torso_guardbase
+   0, // torso_patrol
+   0, // torso_followme
+   0, // torso_affirmative
+   0, // torso_negative
+#endif
 };
+#endif
 
-int s_animSyncWarning[ MD3_ANIMATIONS ] = 
+#ifdef MD3_GENERAL
+const char *s_animSyncWarning[] =
 {
+   "torso_attack",
+   "torso_attack2",
+   "torso_drop",
+   "torso_raise",
+   NULL
+};
+#else
+int s_animSyncWarning[ MD3_ANIMATIONS ] =
+{
    0, // both_death1
    0, // both_dead1
    0, // both_death2
@@ -153,7 +212,16 @@
    0, // legs_idle
    0, // legs_idlecr
    0, // legs_turn
+#ifdef MISSIONPACK
+   0, // torso_getflag
+   0, // torso_guardbase
+   0, // torso_patrol
+   0, // torso_followme
+   0, // torso_affirmative
+   0, // torso_negative
+#endif
 };
+#endif
 
 Md3Filter::Md3Filter()
 {
@@ -202,14 +270,25 @@
       string lowerFile = m_modelPath + fixFileCase( m_modelPath.c_str(), "lower.md3" );
       string upperFile = m_modelPath + fixFileCase( m_modelPath.c_str(), "upper.md3" );
       string headFile  = m_modelPath + fixFileCase( m_modelPath.c_str(), "head.md3"  );
+#ifdef MDR_LOAD
+      string lowerFileMDR = m_modelPath + fixFileCase( m_modelPath.c_str(), "lower.mdr" );
+      string upperFileMDR = m_modelPath + fixFileCase( m_modelPath.c_str(), "upper.mdr" );
+      string headFileMDR  = m_modelPath + fixFileCase( m_modelPath.c_str(), "head.mdr"  );
+#endif
 
-      if (     strncasecmp( m_modelBaseName.c_str(), "lower.", 6 ) == 0 
-            || strncasecmp( m_modelBaseName.c_str(), "upper.", 6 ) == 0 
+      if (     strncasecmp( m_modelBaseName.c_str(), "lower.", 6 ) == 0
+            || strncasecmp( m_modelBaseName.c_str(), "upper.", 6 ) == 0
             || strncasecmp( m_modelBaseName.c_str(), "head.",  5 ) == 0 )
       {
+#ifdef MDR_LOAD
+         if ( (file_exists( lowerFile.c_str() ) || file_exists( lowerFileMDR.c_str() ))
+               && (file_exists( upperFile.c_str() ) || file_exists( upperFileMDR.c_str() ))
+               && (file_exists( headFile.c_str() ) || file_exists( headFileMDR.c_str() )) )
+#else
          if ( file_exists( lowerFile.c_str() )
                && file_exists( upperFile.c_str() )
                && file_exists( headFile.c_str() ) )
+#endif
          {
             log_debug( "have all files for %s\n", m_modelPath.c_str() );
 
@@ -235,7 +314,14 @@
          Md3FileDataT fd;
 
          fd.section = MS_Lower;
+#ifdef MDR_LOAD
+         if ( file_exists( lowerFileMDR.c_str() )
+         	fd.modelBaseName = "lower.mdr";
+         else
+         	fd.modelBaseName = "lower.md3";
+#else
          fd.modelBaseName = "lower.md3";
+#endif
          fd.modelFile = lowerFile;
          fd.tag = "";
          fd.tagPoint = -1;
@@ -248,13 +334,27 @@
          fileList.push_back( fd );
 
          fd.section = MS_Upper;
+#ifdef MDR_LOAD
+         if ( file_exists( upperFileMDR.c_str() )
+         	fd.modelBaseName = "upper.mdr";
+         else
+         	fd.modelBaseName = "upper.md3";
+#else
          fd.modelBaseName = "upper.md3";
+#endif
          fd.modelFile = upperFile;
          fd.tag = "tag_torso";
          fileList.push_back( fd );
 
          fd.section = MS_Head;
+#ifdef MDR_LOAD
+         if ( file_exists( headFileMDR.c_str() )
+         	fd.modelBaseName = "upper.mdr";
+         else
+         	fd.modelBaseName = "upper.md3";
+#else
          fd.modelBaseName = "head.md3";
+#endif
          fd.modelFile = headFile;
          fd.tag = "tag_head";
          fileList.push_back( fd );
@@ -316,6 +416,101 @@
          readString( pk3Name, sizeof( pk3Name ) );
          replaceBackslash( pk3Name );
 
+#ifdef MDR_LOAD
+         // MD3 header data.
+         int32_t flags = 0; // MD3 only
+         int32_t numFrames = 0;
+         int32_t numTags = 0;
+         int32_t numMeshes = 0; // MD3 only
+         int32_t numSkins = 0; // MD3 only
+         int32_t offsetFrames = 0;
+         int32_t offsetTags = 0;
+         int32_t offsetMeshes = 0; // MD3 only
+         int32_t offsetEnd = 0;
+
+         // MDR header data.
+         //int32_t numFrames = 0;
+         int32_t numBones = 0;
+         //int32_t offsetFrames = 0;
+         int32_t numLODs = 0;
+         int32_t offsetLODs = 0;
+         //int32_t numTags = 0;
+         //int32_t offsetTags = 0;
+         //int32_t offsetEnd = 0;
+
+         if ((*it).type == MT_MDR)
+         {
+            numFrames = readI4();
+            numBones = readI4();
+            offsetFrames = readI4();
+            numLODs = readI4();
+            offsetLODs = readI4();
+            numTags = readI4();
+            offsetTags = readI4();
+            offsetEnd = readI4();
+
+            log_debug( "Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+            log_debug( "Version: %d\n",     version );
+            log_debug( "PK3 Name: %s\n",    pk3Name );
+            log_debug( "Frames: %d\n",      numFrames );
+            log_debug( "Bones: %d\n",    numBones );
+            log_debug( "Offset Frames: %d\n",      offsetFrames );
+            log_debug( "LODs: %d\n",       numLODs );
+            log_debug( "Offset LODs: %d\n",      offsetLODs );
+            log_debug( "Tags: %d\n",        numTags );
+            log_debug( "Offset Tags: %d\n",  offsetTags );
+            log_debug( "Offset End: %d\n",        offsetEnd );
+            log_debug( "File Length: %d\n",       fileLength );
+
+            if ( magic[0] != 'R' && magic[1] != 'D' && magic[2] != 'M' && magic[3] != '5' )
+            {
+               log_debug( "Bad Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+               return Model::ERROR_BAD_MAGIC;
+            }
+
+            if ( version != MDR_VERSION )
+            {
+               return Model::ERROR_UNSUPPORTED_VERSION;
+            }
+         }
+         else // MT_MD3
+         {
+            flags = readI4();
+            numFrames = readI4();
+            numTags = readI4();
+            numMeshes = readI4();
+            numSkins = readI4();
+            offsetFrames = readI4();
+            offsetTags = readI4();
+            offsetMeshes = readI4();
+            offsetEnd = readI4();
+
+            log_debug( "Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+            log_debug( "Version: %d\n",     version );
+            log_debug( "PK3 Name: %s\n",    pk3Name );
+            log_debug( "Flags: %d\n",    flags );
+            log_debug( "Frames: %d\n",      numFrames );
+            log_debug( "Tags: %d\n",        numTags );
+            log_debug( "Meshes: %d\n",    numMeshes );
+            log_debug( "Skins: %d\n",       numSkins );
+            log_debug( "Offset Frames: %d\n",      offsetFrames );
+            log_debug( "Offset Tags: %d\n",  offsetTags );
+            log_debug( "Offset Meshes: %d\n",  offsetMeshes );
+            log_debug( "Offset End: %d\n",        offsetEnd );
+            log_debug( "File Length: %d\n",       fileLength );
+
+            if ( magic[0] != 'I' && magic[1] != 'D' && magic[2] != 'P' && magic[3] != '3' )
+            {
+               log_debug( "Bad Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+               return Model::ERROR_BAD_MAGIC;
+            }
+
+            if ( version != MD3_VERSION )
+            {
+               return Model::ERROR_UNSUPPORTED_VERSION;
+            }
+         }
+#else
          int32_t flags = m_src->readI32();
          int32_t numFrames = m_src->readI32();
          int32_t numTags = m_src->readI32();
@@ -350,8 +545,9 @@
          {
             return Model::ERROR_UNSUPPORTED_VERSION;
          }
+#endif
 
-         
+
          Md3PathT mpath;
          mpath.section  = (*it).section;
          mpath.material = -1;
@@ -364,6 +560,10 @@
          // frames
          // mm3d doesn't need this, but nice to have if you ever need to debug
 
+#ifdef MDR_LOAD
+         if ((*it).type == MT_MD3)
+         {
+#endif
 #if 0
          m_src->seek( offsetFrames );
          for ( int i = 0; i < numFrames; i++ )
@@ -398,6 +598,9 @@
             log_debug( "Frame %d name: %s\n", i, frameName );
          }
 #endif // 1
+#ifdef MDR_LOAD
+         }
+#endif
 
          if ( (*it).tag.size() > 0 )
          {
@@ -405,9 +608,16 @@
             log_debug( "tag point for %s is %d\n", (*it).tag.c_str(), (*it).tagPoint );
          }
 
+#ifdef MDR_LOAD
+         if ((*it).type == MT_MD3)
+         {
+#endif
          m_meshVecInfos = new MeshVectorInfoT*[numMeshes];
          setPoints( (*it).section, offsetTags, numTags, numFrames, (*it).tagPoint, -1 );
          setMeshes( (*it).section, offsetMeshes, numMeshes, (*it).tagPoint, -1 );
+#ifdef MDR_LOAD
+         }
+#endif
 
          (*it).meshVecInfos = m_meshVecInfos;
          (*it).src = m_src;
@@ -416,6 +626,11 @@
          (*it).offsetTags = offsetTags;
          (*it).numTags = numTags;
          (*it).numFrames = numFrames;
+#ifdef MDR_LOAD
+         (*it).numBones = numBones;
+         (*it).numLODs = numLODs;
+         (*it).offsetLODs = offsetLODs;
+#endif
       }
 
       if ( fileList.front().numFrames > 1 )
@@ -427,11 +642,19 @@
             {
                int animIndex = m_model->addAnimation( Model::ANIMMODE_FRAME, "AnimFrames" );
                m_model->setAnimFPS( Model::ANIMMODE_FRAME, animIndex, 15.0);
+#ifdef MD3_GENERAL // BUGFIX
+               m_model->setAnimFrameCount( Model::ANIMMODE_FRAME, animIndex, fileList.front().numFrames );
+#else
                m_model->setAnimFrameCount( Model::ANIMMODE_FRAME, 0, fileList.front().numFrames );
+#endif
             }
          }
       }
 
+#ifdef MDR_LOAD
+      if ((*it).type == MT_MD3)
+      {
+#endif
       for ( it = fileList.begin(); it != fileList.end(); it++ )
       {
          m_meshVecInfos = (*it).meshVecInfos;
@@ -445,6 +668,9 @@
             setMeshes( (*it).section, (*it).offsetMeshes, (*it).numMeshes, (*it).tagPoint, animIndex );
          }
       }
+#ifdef MDR_LOAD
+      }
+#endif
 
       // Set MD3_PATH
       size_t len = m_pathList.size();
@@ -497,6 +723,10 @@
          }
       }
 
+#ifdef MDR_LOAD
+      if ((*it).type == MT_MD3)
+      {
+#endif
       // Clean-up
       for ( it = fileList.begin(); it != fileList.end(); it++ )
       {
@@ -509,6 +739,9 @@
          (*it).src->close();
          (*it).src = NULL;
       }
+#ifdef MDR_LOAD
+      }
+#endif
 
       return Model::ERROR_NONE;
    }
@@ -531,6 +764,10 @@
    string animFile = m_modelPath + "animation.cfg";
    FILE * fp = fopen( animFile.c_str(), "r" );
    int animCount = 0;
+#ifdef MD3_GENERAL
+   std::vector<std::string> animNames;
+   int last_fcount = 0;
+#endif
 
    m_animStartFrame.clear();
    m_standFrame = 0;
@@ -563,10 +800,31 @@
             int fcount = 0;
             int loop   = 0;
             int fps    = 0;
+#ifdef MD3_GENERAL
+			char comment[128] = { 0 }; // May hold "//" or "//BOTH_x..."
+			char fname[128] = { 0 }; // May hold "BOTH_x..."
+			// Loads the following types
+			// "0 5 5 15"
+			// "0 5 5 15 //"
+			// "0 5 5 15 //BOTH_DEATH1"
+			// "0 5 5 15 // BOTH_DEATH1"
+			// "0 5 5 15 //         BOTH_DEATH1"
+			// "BOTH_DEATH1 0 5 5 15" (Elite Force Single Player style)
+			// If EF SP style, must check if valid animation name
+			//   (or metadata could be loaded as animation)
+            if ( sscanf( line, "%d %d %d %d %s %s",
+                   &first, &fcount, &loop, &fps, comment, fname ) >= 4
+			    || (sscanf( line, "%s %d %d %d %d",
+                      fname, &first, &fcount, &loop, &fps ) == 5
+				    && (strncasecmp(fname, "both_", 5) == 0 || strncasecmp(fname, "torso_", 6) == 0
+                      || strncasecmp(fname, "legs_", 5) == 0) ))
+#else
             if ( sscanf( line, "%d %d %d %d",
                      &first, &fcount, &loop, &fps ) == 4 )
+#endif
             {
                log_debug( "got anim frame details\n" );
+#ifndef MD3_GENERAL
                if ( animCount == 11 )
                {
                   m_standFrame = first;
@@ -575,8 +833,58 @@
                {
                   m_idleFrame = first;
                }
+#endif
 
+#ifdef MD3_GENERAL
+               // Check for animations that are played in reverse
+               if (fcount < 0)
+               {
+                  // Make a note that it is reversed?
+                  fcount = abs(fcount);
+               }
+
+               char * name = NULL;
+
+               // Check if read name from file.
+               if (strlen(comment) > 7 || strlen(fname) > 5)
+               {
+                  // "//BOTH_x..."
+                  if (strlen(comment) > 7)
+                  {
+                     name = &comment[2];
+                  }
+                  // "BOTH_x..."
+                  else //if (strlen(fname) > 5)
+                  {
+                     name = fname;
+                  }
+
+                  for ( int i = 0; name[i]; i++ )
+                  {
+                     name[i] = tolower( name[i] );
+                  }
+               }
+               else
+               {
+                  // Failed to load name from file, use default.
+                  if ( animCount < MD3_ANIMATIONS )
+                  {
+                     // I won't change it, I promise
+                     name = (char *) s_animNames[ animCount ];
+                  }
+                  else
+                  {
+                     name = (char *) "Unknown";
+                  }
+               }
+               // Save name for offset fixing after animations are loaded.
+               animNames.push_back(name);
+
+               // It's a "both_" animation
+               if ( strncasecmp( name, "both_", 5 ) == 0 )
+#else
                if ( animCount < 6 )
+#endif
                {
                   if ( first + fcount > legsEnd )
                   {
@@ -591,8 +899,30 @@
                         bothEnd = std::max(bothEnd, first + fcount);
                      }
                   }
+#ifdef MD3_GENERAL
+                  // Check for single frame dead animation that use the last
+                  //   frame of the death animation
+                  if (animCount > 0 && strncasecmp(name, "both_dead", 9) == 0
+                     && strncasecmp(animNames[animCount-1].c_str(), "both_death", 10) == 0
+                     && fcount <= 1 )
+                  {
+                     if (m_animStartFrame[animCount-1] + last_fcount - 1 == first)
+                     {
+                        fcount = 0;
+                     }
+                  }
+#endif
                }
-               else if ( animCount < 13 )
+#ifdef MD3_GENERAL
+               // It's a "torso_" animation
+               else if ( strncasecmp( name, "torso_", 6 ) == 0 )
+#else
+               else if ( animCount < 13
+#ifdef MISSIONPACK // Extra team arena animations are torso not legs.
+                  || ( animCount >= MD3_Q3_ANIMATIONS && animCount < MD3_ANIMATIONS )
+#endif
+                  )
+#endif
                {
                   if ( first + fcount > legsEnd )
                   {
@@ -607,8 +937,20 @@
                         torsoEnd = std::max(torsoEnd, first + fcount);
                      }
                   }
+#ifdef MD3_GENERAL
+                  // if name is "torso_stand"
+                  if ( strcasecmp(name, "torso_stand") == 0 )
+                  {
+                     m_standFrame = first;
+                  }
+#endif
                }
+#ifdef MD3_GENERAL
+               // It's a "legs_" animation
+               else if ( strncasecmp( name, "legs_", 5 ) == 0 )
+#else
                else
+#endif
                {
                   if ( legsStart == -1 )
                   {
@@ -620,12 +962,26 @@
                      legsStart = std::min(legsStart, first);
                      legsEnd = std::max(legsEnd, first + fcount);
                   }
+#ifdef MD3_GENERAL
+                  if ( strcasecmp(name, "legs_idle") == 0 )
+                  {
+                     m_idleFrame = first;
+                  }
+#endif
                }
+#ifdef MD3_GENERAL
+				else
+				{
+					// Unknown animation
+					log_debug( "unknown animation type-prefix '%s'\n", name );
+				}
+#endif
 
                m_animStartFrame.push_back( first );
 
                if ( create )
                {
+#ifndef MD3_GENERAL
                   const char * name = NULL;
                   if ( animCount < MD3_ANIMATIONS )
                   {
@@ -660,19 +1016,75 @@
                         name = "Unknown";
                      }
                   }
+#endif
 
                   log_debug( "adding animation '%s'\n", name );
+#ifdef MD3_GENERAL // BUGFIX
+                  int animIndex = m_model->addAnimation( Model::ANIMMODE_FRAME, name );
+#else
                   int animIndex = m_model->addAnimation( Model::ANIMMODE_FRAME, s_animNames[ animCount ] );
+#endif
                   m_model->setAnimFPS( Model::ANIMMODE_FRAME, animIndex, (double) fps );
                   m_model->setAnimFrameCount( Model::ANIMMODE_FRAME, animIndex, fcount );
                }
 
                animCount++;
+#ifdef MD3_GENERAL
+               last_fcount = fcount;
+#endif
             }
             else
             {
                if ( create )
                {
+#ifdef MD3_GENERAL // TODO: Make sure this works!
+                  bool hasKeyword = false;
+                  char *name = NULL;
+                  std::string str;
+
+                  // save "name value"
+                  name = line;
+                  while( isspace(name[0]) )
+                  {
+                     name++;
+                  }
+                  int end = 0;
+                  while ( name[end] && name[end] != '\r' && name[end] != '\n' )
+                  {
+                     if (isspace(name[end]))
+                     {
+                        hasKeyword = true;
+                        break;
+                     }
+                     end++;
+                  }
+                  name[end] = '\0';
+                  end++;
+                  // TODO: Use MAX_DATAFIELD?
+                  str = "MD3_CFG_";
+                  str += name;
+
+                  if (hasKeyword)
+                  {
+                     char *value = &name[end];
+                     while( isspace(value[0]) )
+                     {
+                        value++;
+                     }
+                     end = 0;
+                     while ( value[end] && value[end] != '\r' && value[end] != '\n' )
+                     {
+                        end++;
+                     }
+                     value[end] = '\0';
+
+                     m_model->addMetaData( str.c_str(), value );
+                  }
+                  else
+                  {
+                    m_model->addMetaData( str.c_str(), "" );
+                  }
+#else
                   char * value = NULL;
                   if ( strncasecmp( line, "sex", 3 ) == 0 )
                   {
@@ -737,6 +1149,7 @@
                   {
                      log_warning( "Unknown meta data: %s", line );
                   }
+#endif
                }
             }
          }
@@ -744,7 +1157,20 @@
 
       fclose( fp );
 
-      // Some animation files have the leg frames continuously numbered 
+#ifdef MD3_GENERAL
+      if (m_standFrame == 0)
+      {
+         // Didn't find "torso_stand"
+         m_standFrame = torsoStart;
+      }
+      if (m_idleFrame == 0)
+      {
+         // Didn't find "legs_idle"
+         m_idleFrame = legsStart;
+      }
+#endif
+
+      // Some animation files have the leg frames continuously numbered
       // after the torso frames, others number the legs following the
       // "both" frames. Here we are adjusting the first case to make
       // it match the second case.
@@ -752,12 +1178,25 @@
       if ( legsStart >= torsoEnd )
       {
          int animOffset = legsStart - torsoStart;
+#ifdef MD3_GENERAL
+         for ( size_t a = 0; a < m_animStartFrame.size(); ++a )
+#else
          for ( size_t a = 13; a < m_animStartFrame.size(); ++a )
+#endif
          {
+#ifdef MD3_GENERAL
+            if ( strncasecmp( animNames[a].c_str(), "legs_", 5 ) != 0 )
+               continue;
+#else
+#ifdef MISSIONPACK // Extra team arena animations are torso not legs.
+            if ( a >= (size_t)MD3_Q3_ANIMATIONS && a < (size_t)MD3_ANIMATIONS)
+               continue;
+#endif
+#endif
             if ( m_animStartFrame[a] >= animOffset )
                m_animStartFrame[a] -= animOffset;
          }
-         
+
          if ( m_idleFrame >= animOffset )
             m_idleFrame -= animOffset;
       }
@@ -1569,13 +2008,32 @@
          return true;
       }
    }
-   else if ( strcasecmp( tagName.c_str(), "tag_weapon" ) == 0 )
+   else if ( strcasecmp( tagName.c_str(), "tag_weapon" ) == 0
+#if defined MISSIONPACK || defined MD3_GENERAL
+      || strcasecmp( tagName.c_str(), "tag_flag" ) == 0
+#endif
+#ifdef TMNT // Tags used in yet-to-be release TMNT Arena ...
+      || strcasecmp( tagName.c_str(), "tag_hand_primary" ) == 0
+      || strcasecmp( tagName.c_str(), "tag_hand_secondary" ) == 0
+      || strcasecmp( tagName.c_str(), "tag_wp_away_primary" ) == 0
+      || strcasecmp( tagName.c_str(), "tag_wp_away_secondary" ) == 0
+#endif
+      )
    {
       if ( section == MS_Upper )
       {
          return true;
       }
    }
+#ifdef MD3_GENERAL // Support unknown tags. Mods could add new tags.
+   else
+   {
+      // Better to have unknown tag in all models then none.
+      // In Quake3 the programmer selects which section the tag is on,
+      //   so it should be harmless.
+      return true;
+   }
+#endif
 
    return false;
 }
@@ -1621,7 +2079,7 @@
 
    return animName;
 }
- 
+
 Model::ModelErrorE Md3Filter::writeFile( Model * model, const char * const filename, ModelFilter::Options *  )
 {
    if ( model && filename && filename[0] )
@@ -1697,8 +2155,8 @@
 
       if ( saveAsPlayer )
       {
-         if (     strncasecmp( modelBaseName.c_str(), "lower.", 6 ) == 0 
-               || strncasecmp( modelBaseName.c_str(), "upper.", 6 ) == 0 
+         if (     strncasecmp( modelBaseName.c_str(), "lower.", 6 ) == 0
+               || strncasecmp( modelBaseName.c_str(), "upper.", 6 ) == 0
                || strncasecmp( modelBaseName.c_str(), "head.",  5 ) == 0 )
          {
             log_debug( "filename %s looks like a player model\n", modelBaseName.c_str() );
@@ -1713,8 +2171,25 @@
             }
             else
             {
+#ifdef MD3_GENERAL // BUGFIX: Automaticly saving as player was causing me some problems...
+		        char answer = msg_info_prompt( transll( QT_TRANSLATE_NOOP( "LowLevel", "This looks like a player model.\nDo you want to save all sections?")).c_str(), "Ync" );
+		        if ( answer == 'Y' )
+		        {
+		           model->addMetaData( "MD3_composite", "1" );
+		        }
+		        else if ( answer == 'N' )
+		        {
+		           model->addMetaData( "MD3_composite", "0" );
+		           saveAsPlayer = false;
+		        }
+		        else
+		        {
+		           return Model::ERROR_CANCEL;
+		        }
+#else
                // TODO: Eventually create a prompt instead of assuming "yes"
                log_debug( "model is implicitly a composite (no composite meta tag)\n" );
+#endif
             }
          }
          else
@@ -1757,12 +2232,28 @@
    }
 }
 
-Model::ModelErrorE Md3Filter::writeSectionFile( const char * filename, Md3Filter::MeshSectionE section, MeshList & meshes )
+Model::ModelErrorE Md3Filter::writeSectionFile( const char * filename, 
+#ifdef MDR_EXPORT
+   Md3Filter::MeshTypeE type,
+#endif
+   Md3Filter::MeshSectionE section, MeshList & meshes )
 {
    string modelPath = "";
    string modelBaseName = "";
    string modelFullName = "";
+#ifdef MDR_EXPORT
+   Model::AnimationModeE animationMode;
 
+   if (type == MT_MDR)
+   {
+      animationMode = Model::ANIMMODE_SKELETAL;
+   }
+   else // MT_MD3
+   {
+      animationMode = Model::ANIMMODE_FRAME;
+   }
+#endif
+
    log_debug( "writing section file %s\n", filename );
    switch ( section )
    {
@@ -1785,6 +2276,28 @@
 
    normalizePath( filename, modelFullName, modelPath, modelBaseName );
 
+#ifdef MDR_EXPORT
+
+   int8_t magic[4];
+   int32_t version = 0;
+   if (type == MT_MDR)
+   {
+      //MDR HEADER
+      magic[0] = 'R';
+      magic[1] = 'D';
+      magic[2] = 'M';
+      magic[3] = '5';
+      version = MDR_VERSION;
+   }
+   else
+   {
+      magic[0] = 'I';
+      magic[1] = 'D';
+      magic[2] = 'P';
+      magic[3] = '3';
+      version = MD3_VERSION;
+   }
+#else
    //MD3 HEADER
    int8_t magic[4];
    magic[0] = 'I';
@@ -1792,13 +2305,14 @@
    magic[2] = 'P';
    magic[3] = '3';
    int32_t version = MD3_VERSION;
+#endif
    char pk3Name[MAX_QPATH];
    std::string pk3Path = "";
    memset( pk3Name, 0, MAX_QPATH );
 
    pk3Path = sectionToPath( section );
-   if ( !pk3Path.empty() 
-         && pk3Path[pk3Path.size() - 1] != '/' 
+   if ( !pk3Path.empty()
+         && pk3Path[pk3Path.size() - 1] != '/'
          && pk3Path.size() < ( MAX_QPATH+1 ) )
    {
       pk3Path += "/";
@@ -1814,14 +2328,22 @@
    int32_t flags = 0;
    int32_t numFrames = 0;
    //We are making all the anims be one anim.
+#ifdef MDR_EXPORT
+   unsigned animCount = m_model->getAnimCount( animationMode );
+#else
    unsigned animCount = m_model->getAnimCount( Model::ANIMMODE_FRAME );
+#endif
    for ( unsigned i = 0; i < animCount; i++ )
    {
       // Skip animations that don't belong in this section
       std::string name = getSafeName( i );
       if ( animInSection( name, section ) )
       {
+#ifdef MDR_EXPORT
+         numFrames += m_model->getAnimFrameCount( animationMode, i );
+#else
          numFrames += m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, i );
+#endif
       }
    }
 
@@ -1842,7 +2364,22 @@
    }
 
    unsigned pcount = m_model->getPointCount();
+#ifdef MD3_GENERAL
    int32_t numTags = (int32_t) pcount;
+   // If spliting model count tags.
+   if (section == MS_Head || section == MS_Lower || section == MS_Upper)
+   {
+      numTags = 0;
+      for ( unsigned j = 0; j < pcount; j++ )
+      {
+         if ( tagInSection( m_model->getPointName( j ), section ) )
+         {
+            numTags++;
+         }
+      }
+   }
+#else
+   int32_t numTags = (int32_t) pcount;
    switch ( section )
    {
       case MS_Head:
@@ -1851,10 +2388,22 @@
          break;
       case MS_Upper:
          numTags = 3;
+#ifdef MISSIONPACK
+         // Check for "tag_flag"
+         for ( unsigned j = 0; j < pcount; j++ )
+         {
+            if ( strncasecmp( m_model->getPointName( j ), "tag_flag", 8) == 0 )
+            {
+               numTags++;
+               break;
+            }
+         }
+#endif
          break;
       default:
          break;
    }
+#endif
 
    MeshList::iterator mlit;
 
@@ -1880,7 +2429,7 @@
       }
    }
 
-   int32_t numSkins = 0;
+   int32_t numSkins = 0; // MD3
    if ( numTags > MD3_MAX_TAGS )
    {
       log_error( "Number of tags(%d) is larger than %d\n.\n", numTags, MD3_MAX_TAGS );
@@ -1894,10 +2443,36 @@
       return Model::ERROR_FILTER_SPECIFIC;
    }
    // numSkins is usually zero for MD3 header, there can be skins for each mesh though later
+#ifdef MDR_EXPORT
+   int32_t numBones = 0; // MDR
+   int32_t offsetFrames = 0;
+   int32_t numLODs = 0; // MDR
+   int32_t offsetLODs = 0; // MDR
+   int32_t offsetTags = 0;
+   int32_t offsetMeshes = 0; // MD3
+   int32_t offsetEnd = 0;
+   if (type == MT_MDR)
+   {
+      numBones = m_model->getBoneJointCount(); // FIXME: Is this right?
+      offsetFrames = MDR_HEADER_SIZE;
+      numLODs = 1;
+      offsetLODs = offsetFrames + numFrames * (MDR_FRAME_SIZE + numBones * MDR_BONE_SIZE);
+      offsetTags = offsetFrames + numFrames * MDR_LOD_SIZE;
+      offsetEnd = offsetTags;
+   }
+   else
+   {
+      offsetFrames = MD3_HEADER_SIZE;
+      offsetTags = offsetFrames + numFrames * MD3_FRAME_SIZE;
+      offsetMeshes = offsetTags + numFrames * numTags * MD3_TAG_SIZE;
+      offsetEnd = offsetMeshes;
+   }
+#else
    int32_t offsetFrames = HEADER_SIZE;
    int32_t offsetTags = offsetFrames + numFrames * FRAME_SIZE;
    int32_t offsetMeshes = offsetTags + numFrames * numTags * TAG_SIZE;
    int32_t offsetEnd = offsetMeshes;
+#endif
 
    // MD3 limit tests
    if ( numTris > MD3_MAX_TRIANGLES )
@@ -1922,6 +2497,26 @@
       return err;
 
    // write file header
+#ifdef MDR_EXPORT
+   if (type == MT_MDR)
+   {
+      m_dst->write( magic[0] );
+      m_dst->write( magic[1] );
+      m_dst->write( magic[2] );
+      m_dst->write( magic[3] );
+      m_dst->write( version );
+      m_dst->writeS( pk3Name, MAX_QPATH );
+      m_dst->write( numFrames );
+      m_dst->write( numBones );
+      m_dst->write( offsetFrames );
+      m_dst->write( numLODs );
+      m_dst->write( offsetLODs );
+      m_dst->write( numTags );
+      m_dst->write( offsetTags );
+   }
+   else
+   {
+#endif
    m_dst->write( magic[0] );
    m_dst->write( magic[1] );
    m_dst->write( magic[2] );
@@ -1936,6 +2531,9 @@
    m_dst->write( offsetFrames );
    m_dst->write( offsetTags );
    m_dst->write( offsetMeshes );
+#ifdef MDR_EXPORT
+   }
+#endif
 
    uint32_t endPos = m_dst->offset();
    m_dst->write( offsetEnd );
@@ -1958,10 +2556,14 @@
 
    for ( a = 0; a < animCount; a++ )
    {
-      if ( animInSection( getSafeName( a ), section ) 
+      if ( animInSection( getSafeName( a ), section )
             || (section == MS_Head && a == 0) )
       {
+#ifdef MDR_EXPORT
+         unsigned aFrameCount = m_model->getAnimFrameCount( animationMode, a );
+#else
          unsigned aFrameCount = m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, a );
+#endif
          if ( (aFrameCount == 0 && animCount == 1 )
                || (section == MS_Head) )
          {
@@ -2029,16 +2631,39 @@
             char name[16] = "Misfit Model 3D"; // this is what other exporters do
             PORT_snprintf( name, sizeof(name), "%s%02d", animName.c_str(), t);
             m_dst->writeBytes( (uint8_t*) name, sizeof(name) );
+
+#ifdef MDR_EXPORT
+            if (type == MT_MDR)
+            {
+               // FIXME: Write bone locations.
+               // float		matrix[3][4]; --to be written for each bone.
+               for (unsigned bone = 0; bone < numBones; bone++)
+               {
+                  //m_model->getBoneJointFinalMatrix(bone, m);
+                  //m_model->getBoneVector(bone, ..., ...);
+                  //bool getBoneVector( unsigned joint, double * vec, double * coord );
+               }
+            }
+#endif
          }
       }
    }
 
+#ifdef MDR_EXPORT
+   if (type == MT_MDR)
+   {
+      // Tags in MDR are done later.
+   }
+   else // MT_MD3
+   {
+#endif
+
    //TAGS
    log_debug( "writing tags at %d/%d\n", offsetTags, m_dst->offset() );
 
    for ( a = 0; a < animCount; a++ )
    {
-      if ( animInSection( getSafeName( a ), section ) 
+      if ( animInSection( getSafeName( a ), section )
             || (section == MS_Head && a == 0) )
       {
          unsigned aFrameCount = m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, a );
@@ -2100,9 +2725,45 @@
          }
       }
    }
+#ifdef MDR_EXPORT
+   }
+#endif
 
    vector<Model::Material *> & modelMaterials = getMaterialList( m_model );
 
+#ifdef MDR_EXPORT
+   if (type == MT_MDR)
+   {
+      // LODs
+      //log_debug( "writing LODs at %d/%d\n", offsetLODs, ftell( m_fpOut ) );
+#if 1
+      // Write LODs
+      for (unsigned i = 0; i < numLODs; i++)
+      {
+         //
+      }
+
+      // Write meshes
+      for (unsigned i = 0; i < numLODs; i++)
+      {
+         //
+      }
+#else // Below is what needs to be done.
+      //for each LOD
+         // write the number of surfaces (Meshes) (numSurfaces),
+         // offset of the first surfaces (Meshes) (offsetSurfaces),
+         // and the offset of the next LOD (offsetEnd)
+
+      // end LODs
+
+      // for each LOD
+         // Write surface (Mesh)
+      // end surfaces (Meshes)
+#endif
+   }
+   else // MT_MD3
+   {
+#endif
    // MESHES
    log_debug( "writing meshes at %d/%d\n", offsetMeshes, m_dst->offset() );
 
@@ -2195,8 +2856,8 @@
             if ( matId >= 0 )
             {
                spk3Path = materialToPath( matId );
-               if ( !spk3Path.empty() 
-                     && spk3Path[spk3Path.size() - 1] != '/' 
+               if ( !spk3Path.empty()
+                     && spk3Path[spk3Path.size() - 1] != '/'
                      && spk3Path.size() < ( MAX_QPATH+1 ) )
                {
                   spk3Path += "/";
@@ -2234,7 +2895,7 @@
             else
             {
                log_debug( "path is relative, using as-is\n" );
-               // relative path... sounds like a fallback, just use 
+               // relative path... sounds like a fallback, just use
                // matFileName as is
                PORT_snprintf( sName, sizeof(sName), "%s", matFileName.c_str() );
             }
@@ -2257,7 +2918,7 @@
          m_model->calculateNormals();
          for ( unsigned a = 0; a < animCount; a++ )
          {
-            if ( animInSection( getSafeName( a ), section ) 
+            if ( animInSection( getSafeName( a ), section )
                   || (section == MS_Head && a == 0) )
             {
                // If there are no anims calculateFrameNormals will segfault
@@ -2267,7 +2928,7 @@
                   m_model->calculateFrameNormals( a );
                }
                unsigned aFrameCount = m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, a );
-               if ( (aFrameCount == 0 && animCount == 1) 
+               if ( (aFrameCount == 0 && animCount == 1)
                      || (section == MS_Head) )
                {
                   aFrameCount = 1;
@@ -2345,7 +3006,41 @@
          }
       }
    }
+#ifdef MDR_EXPORT
+   }
 
+   if (type == MT_MDR)
+   {
+      //TAGS
+      log_debug( "writing tags at %d/%d\n", offsetTags, ftell( m_fpOut ) );
+
+      // Tags in MDR are simple (bone index and name)
+      for ( unsigned j = 0; j < pcount; j++ )
+      {
+         if ( tagInSection( m_model->getPointName( j ), section ) )
+         {
+            int32_t boneIndex = m_model->getPointBoneJoint(j);
+			m_dst->write(boneIndex);
+
+            char tName[32];
+            memset( tName, 0, sizeof( tName ) );
+            if ( PORT_snprintf( tName, sizeof( tName ), "%s", m_model->getPointName( j ) ) >= sizeof( tName ) )
+            {
+               fclose( m_fpOut );
+               log_error( "Point name is too large\n" );
+               m_model->setFilterSpecificError( "Point name is too large for MD3 export." );
+               return Model::ERROR_FILTER_SPECIFIC;
+            }
+            m_dst->writeS( tName, sizeof( tName ) );
+         }
+      }
+   }
+   else // MT_MD3
+   {
+      // Tags are done already.
+   }
+#endif
+
    offsetEnd = m_dst->offset();
    m_dst->seek( endPos );
    m_dst->write( offsetEnd );
@@ -2353,6 +3048,32 @@
    return Model::ERROR_NONE;
 }
 
+#ifdef MD3_GENERAL
+bool Md3Filter::AnimLoop(std::string name)
+{
+   for (int i = 0; s_animLoop[i] != NULL; i++)
+   {
+      if (strcmp(s_animLoop[i], name.c_str()) == 0)
+      {
+         return true;
+      }
+   }
+   return false;
+}
+
+bool Md3Filter::AnimSyncWarning(std::string name)
+{
+   for (int i = 0; s_animSyncWarning[i] != NULL; i++)
+   {
+      if (strcmp(s_animSyncWarning[i], name.c_str()) == 0)
+      {
+         return true;
+      }
+   }
+   return false;
+}
+#endif
+
 bool Md3Filter::writeAnimations()
 {
    string animFile = m_modelPath + "/animation.cfg";
@@ -2362,6 +3083,48 @@
    {
       log_debug( "writing animation.cfg\n" );
 
+#ifdef MD3_GENERAL
+      fprintf( fp, "// animation config file\r\n" );
+
+      {
+         bool hadKeyword = false;
+         char keyword[MAX_DATAFIELD], value[MAX_DATAFIELD];
+         for (unsigned int i = 0; i < m_model->getMetaDataCount(); i++)
+         {
+            if (!m_model->getMetaData(i, keyword, MAX_DATAFIELD, value, MAX_DATAFIELD))
+               continue;
+            if (strncasecmp(keyword, "MD3_CFG_", 8) == 0)
+            {
+               if (!hadKeyword)
+               {
+                  hadKeyword = true;
+                  fprintf( fp, "\r\n" );
+               }
+               if (strlen(value) > 0)
+                  fprintf( fp, "%s %s\r\n", &keyword[8], value );
+               else
+                  fprintf( fp, "%s\r\n", &keyword[8] );
+            }
+            // Support old keywords
+			if (strncasecmp(keyword, "MD3_sex", 7) == 0
+			   || strncasecmp(keyword, "MD3_footsteps", 13) == 0
+			   || strncasecmp(keyword, "MD3_headoffset", 14) == 0
+			   || strncasecmp(keyword, "MD3_fixedtorso", 14) == 0
+			   || strncasecmp(keyword, "MD3_fixedlegs", 13) == 0)
+            {
+               if (!hadKeyword)
+               {
+                  hadKeyword = true;
+                  fprintf( fp, "\r\n" );
+               }
+               if (strlen(value) > 0)
+                  fprintf( fp, "%s %s\r\n", &keyword[4], value );
+               else
+                  fprintf( fp, "%s\r\n", &keyword[4] );
+            }
+         }
+      }
+#else
       fprintf( fp, "// animation config file\r\n\r\n" );
 
       char value[30];
@@ -2385,6 +3148,7 @@
       {
          fprintf( fp, "fixedlegs %s\r\n", value );
       }
+#endif
 
       fprintf( fp, "\r\n" );
 
@@ -2392,6 +3156,18 @@
       fprintf( fp, "//    first   count   looping   fps\r\n\r\n" );
 
       char warning[] = " (MUST NOT CHANGE -- hand animation is synced to this)";
+#ifdef MD3_GENERAL
+      size_t animCount = m_model->getAnimCount( Model::ANIMMODE_FRAME );
+      for ( size_t anim = 0; anim < animCount; anim++ )
+      {
+         int animFrame = 0;
+         int count = 1;
+         int fps   = 15;
+         if (!getExportAnimData( (int)anim, animFrame, count, fps ))
+         {
+            continue;
+         }
+#else
       for ( int anim = 0; anim < MD3_ANIMATIONS; anim++ )
       {
          int animIndex = 0;
@@ -2399,15 +3175,32 @@
          int count = 1;
          int fps   = 15;
          getExportAnimData( anim, animIndex, animFrame, count, fps );
+#endif
 
          int loop = count; // loop by default
 
+#ifdef MD3_GENERAL
+         std::string name = getSafeName( anim );
+		 size_t len = name.length();
+         for ( size_t n = 0; n < len; n++ )
+         {
+            name[n] = std::toupper(name[n]);
+         }
+#endif
+
          // disable looping on non-looping anims
-         if ( count <= 1 || s_animLoop[anim] == 0 )
+         if ( count <= 1
+#ifdef MD3_GENERAL
+			|| !AnimLoop(name)
+#else
+            || s_animLoop[anim] == 0
+#endif
+            )
          {
             loop = 0;
          }
 
+#ifndef MD3_GENERAL
          char name[30];
          strcpy( name, s_animNames[anim] );
          size_t len = strlen( name );
@@ -2415,10 +3208,17 @@
          {
             name[n] = toupper( name[n] );
          }
+#endif
 
-         fprintf( fp, "%d\t%d\t%d\t%d\t\t// %s%s\r\n", 
+         fprintf( fp, "%d\t%d\t%d\t%d\t\t// %s%s\r\n",
+#ifdef MD3_GENERAL
+               animFrame, count, loop, fps, name.c_str(),
+               ((anim < (size_t)MD3_ANIMATIONS && AnimSyncWarning(name)) ? warning : "") );
+#else
                animFrame, count, loop, fps, name,
                (s_animSyncWarning[anim] ? warning : "") );
+#endif
+
       }
       fclose( fp );
       return true;
@@ -2458,21 +3258,57 @@
    return m;
 }
 
-void Md3Filter::getExportAnimData( int fileAnim, int & modelAnim, 
+#ifdef MD3_GENERAL
+bool Md3Filter::getExportAnimData( int modelAnim,
       int & fileFrame, int & frameCount, int & fps )
+#else
+void Md3Filter::getExportAnimData( int fileAnim, int & modelAnim,
+      int & fileFrame, int & frameCount, int & fps )
+#endif
 {
    fileFrame  = 0;
    frameCount = 0;
 
    size_t animCount = m_model->getAnimCount( Model::ANIMMODE_FRAME );
+#ifdef MD3_GENERAL
+   MeshSectionE section = MS_None;
+   std::string animName = getSafeName( modelAnim );
 
+   if (strncasecmp(animName.c_str(), "torso_", 6) == 0)
+   {
+      section = MS_Upper;
+   }
+   else if (strncasecmp(animName.c_str(), "legs_", 5) == 0)
+   {
+      section = MS_Lower;
+   }
+
+   // If this is a "dead" animation and its after a "death" animation
+   //   and it has 0 frames, use the last frame of the death animation.
+   if (modelAnim > 0 && strncasecmp(animName.c_str(), "both_dead", 9) == 0
+      && strncasecmp(getSafeName( modelAnim - 1 ).c_str(), "both_death", 10) == 0
+      && m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, modelAnim ) == 0 )
+   {
+      if (getExportAnimData( modelAnim - 1, fileFrame, frameCount, fps ))
+      {
+         fileFrame += frameCount - 1;
+         frameCount = 1;
+         return true;
+      }
+   }
+#endif
+
    for ( size_t a = 0; a < animCount; a++ )
    {
       std::string name = getSafeName( a );
       if ( animInSection( name, MS_Upper )
             || animInSection( name, MS_Lower ) )
       {
+#ifdef MD3_GENERAL
+         if ( a == (size_t)modelAnim )
+#else
          if ( strcasecmp( s_animNames[ fileAnim ], name.c_str() ) == 0 )
+#endif
          {
             frameCount = m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, a );
             fps   = (int) m_model->getAnimFPS( Model::ANIMMODE_FRAME, a );
@@ -2482,15 +3318,39 @@
                fps = 15;
             }
 
+#ifdef MD3_GENERAL
+			if (section == MS_Lower)
+			{
+				// Must still count torso animations after this for fileFrame
+			}
+			else
+			{
+			   return true;
+			}
+#else
             return;
+#endif
          }
          else
+#ifdef MD3_GENERAL // All torso frames from go before leg frames, all legs go after tosro
+         if (section == MS_None || (section == MS_Lower && (a < (size_t)modelAnim || strncasecmp(name.c_str(), "legs_", 5) != 0))
+            || (section == MS_Upper && strncasecmp(name.c_str(), "legs_", 5) != 0))
+#endif
          {
             fileFrame += m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, a );
          }
       }
    }
 
+#ifdef MD3_GENERAL
+   if (section == MS_Lower && frameCount)
+   {
+      // Finished adding up fileFrame for legs animations
+      return true;
+   }
+#endif
+
+#ifndef MD3_GENERAL
    // if this is a "dead" animation and there isn't a "dead" animation, try the
    // last frame of the "death" animation.
    if ( fileAnim < 6 && (fileAnim % 2) == 1 )
@@ -2504,8 +3364,13 @@
          return;
       }
    }
+#endif
 
+#ifdef MD3_GENERAL
+   return false;
+#else
    modelAnim = -1;
+#endif
 }
 
 size_t Md3Filter::writeIdentity()
@@ -2672,7 +3537,11 @@
    log_debug( "isSupported( %s )\n", filename );
    unsigned len = strlen( filename );
 
-   if ( len >= 4 && strcasecmp( &filename[len-4], ".md3" ) == 0 )
+   if ( len >= 4 && strcasecmp( &filename[len-4], ".md3" ) == 0
+#ifdef MDR_GENERAL // Turtle Man: Is this load, export, or both?
+      || len >= 4 && strcasecmp( &filename[len-4], ".mdr" ) == 0
+#endif
+      )
    {
       log_debug( "  true\n" );
       return true;
@@ -2688,6 +3557,9 @@
 {
    list<string> rval;
    rval.push_back( "*.md3" );
+#ifdef MDR_LOAD
+   rval.push_back( "*.mdr" );
+#endif
    return rval;
 }
 
@@ -2695,6 +3567,9 @@
 {
    list<string> rval;
    rval.push_back( "*.md3" );
+#ifdef MDR_EXPORT
+   rval.push_back( "*.mdr" );
+#endif
    return rval;
 }
 
