Index: src/libmm3d/md3filter.h
===================================================================
--- src/libmm3d/md3filter.h	(revision 440)
+++ src/libmm3d/md3filter.h	(working copy)
@@ -28,6 +28,25 @@
 #ifndef __MD3FILTER_H
 #define __MD3FILTER_H
 
+#define TMNT // Enable special support my yet-to-be released Q3 mod, TMNT Arena, that should not be in mm3d :(
+#define MD3_GENERAL // Add generalize support for Team Arena and Smokin' Guns (and maybe other mods)
+
+#ifdef MD3_GENERAL
+#define MAX_DATAFIELD (128) // Max length of MD3 animation config "metadata" to save. 
+// "footsteps" "headoffset" "sex"  (This number is not connected to the MD3 format.)
+#endif
+
+// Turtle Man: TODO: Finish moving unfinished MDR stuff from plugin to here.
+//#define MDR_LOAD // Unfinished
+//#define MDR_EXPORT // Unfinished
+
+#if defined MDR_LOAD || defined MDR_EXPORT
+#define MDR_GENERAL // Stuff for load and export
+#define MDR_VERSION	2
+#endif
+
+
+
 #define MD3_VERSION 15
 #define MAX_QPATH 64
 #define MD3_MAX_FRAMES 1024
@@ -73,6 +92,16 @@
 
    protected:
 
+#ifdef MDR_GENERAL
+      typedef enum _MeshType_e
+      {
+         MT_None = -1,
+         MT_MD3 = 0,
+         MT_MDR,
+         MT_MAX
+      } MeshTypeE;
+#endif
+
       typedef enum _MeshSection_e
       {
          MS_None = -1,
@@ -100,18 +129,27 @@
 
       typedef struct _Md3FileData_t
       {
+#ifdef MDR_GENERAL
+         MeshTypeE type; // MD3 or MDR
+#endif
          MeshSectionE section;
          string modelBaseName;
          string modelFile;
          string tag;
          int32_t tagPoint;
          DataSource * src;
-         int32_t offsetMeshes;
-         int32_t numMeshes;
+         int32_t offsetMeshes; // MD3 only
+         int32_t numMeshes; // MD3 only
          int32_t offsetTags;
          int32_t numTags;
          int32_t numFrames;
-         MeshVectorInfoT ** meshVecInfos;
+         MeshVectorInfoT ** meshVecInfos; // MD3 only
+#ifdef MDR_GENERAL
+         // Only used by MDR
+         int32_t numBones;
+         int32_t numLODs;
+         int32_t offsetLODs;
+#endif
       } Md3FileDataT;
       typedef std::list< Md3FileDataT > Md3FileDataList;
 
@@ -123,6 +161,19 @@
       } Md3PathT;
       typedef std::vector< Md3PathT > Md3PathList;
 
+#ifdef MDR_GENERAL
+      typedef struct _MdrAnimation_t
+      {
+         std::string name;
+         bool loop;
+      } MdrAnimationT;
+      typedef std::vector< MdrAnimationT > MdrAnimatoinList;
+
+      typedef struct {
+      	float		matrix[3][4];
+      } mdrBone_t;
+#endif
+
       unsigned readString( char * dest, size_t len );
 
       bool     readAnimations( bool create );
@@ -165,6 +216,10 @@
 
       //writes
       Model::ModelErrorE writeSectionFile( const char * filename, MeshSectionE section, MeshList & meshes );
+#ifdef MD3_GENERAL
+      bool AnimLoop(std::string name);
+      bool AnimSyncWarning(std::string name);
+#endif
       bool     writeAnimations();
       size_t   writeIdentity();
       DataDest * m_dst;
@@ -174,8 +229,13 @@
       double   greater(double a, double b);
       double   smaller(double a, double b);
       Matrix   getMatrixFromPoint( int anim, int frame, int point );
+#ifdef MD3_GENERAL
+      bool getExportAnimData( int modelAnim,
+            int & fileFrame, int & frameCount, int & fps );
+#else
       void getExportAnimData( int fileAnim, int & modelAnim, 
             int & fileFrame, int & frameCount, int & fps );
+#endif
 
 };
 #endif // __MD3FILTER_H
Index: src/libmm3d/md3filter.cc
===================================================================
--- src/libmm3d/md3filter.cc	(revision 440)
+++ src/libmm3d/md3filter.cc	(working copy)
@@ -66,6 +66,13 @@
 const int HEADER_SIZE = (11 * 4) + MAX_QPATH;
 const int FRAME_SIZE = ( 3 * ( 3 * 4 ) + 4 + 16 );
 const int TAG_SIZE = ( MAX_QPATH + ( 4 * 3 ) + ( 3 * 4 * 3 ) );
+#ifdef MDR_GENERAL
+const int MDR_HEADER_SIZE = (10 * 4) + MAX_QPATH;
+const int MDR_FRAME_SIZE = ( 3 * ( 3 * 4 ) + 4 + 16 ); // NOTE: must add (numBones * sizeof (mdrbone_t))
+const int MDR_BONE_SIZE = (4 * 3 * 4); // TODO: Check num : sizeof (Md3Filter::mdrBone_t);
+const int MDR_LOD_SIZE = (4 + 4 + 4);
+//const int MDR_TAG_SIZE = 32 + 4; // unused?
+#endif
 
 
 const char s_animNames[ MD3_ANIMATIONS ][16] = 
@@ -97,6 +104,22 @@
    "legs_turn",
 };
 
+#ifdef MD3_GENERAL // FIXME: Allow user to have any animation loop
+const char *s_animLoop[] =
+{
+   "torso_stand",
+   "torso_stand2",
+   "legs_walkcr",
+   "legs_walk",
+   "legs_run",
+   "legs_back",
+   "legs_swim",
+   "legs_idle",
+   "legs_idlecr",
+   "legs_turn",
+   NULL
+};
+#else
 int s_animLoop[ MD3_ANIMATIONS ] = 
 {
    0, // both_death1
@@ -125,7 +148,18 @@
    1, // legs_idlecr
    1, // legs_turn
 };
+#endif
 
+#ifdef MD3_GENERAL // FIXME: Allow user to have any animation have sync warning? (Or at least disable?)
+const char *s_animSyncWarning[] =
+{
+   "torso_attack",
+   "torso_attack2",
+   "torso_drop",
+   "torso_raise",
+   NULL
+};
+#else
 int s_animSyncWarning[ MD3_ANIMATIONS ] = 
 {
    0, // both_death1
@@ -154,6 +188,7 @@
    0, // legs_idlecr
    0, // legs_turn
 };
+#endif
 
 Md3Filter::Md3Filter()
 {
@@ -202,14 +237,25 @@
       string lowerFile = m_modelPath + fixFileCase( m_modelPath.c_str(), "lower.md3" );
       string upperFile = m_modelPath + fixFileCase( m_modelPath.c_str(), "upper.md3" );
       string headFile  = m_modelPath + fixFileCase( m_modelPath.c_str(), "head.md3"  );
+#ifdef MDR_LOAD
+      string lowerFileMDR = m_modelPath + fixFileCase( m_modelPath.c_str(), "lower.mdr" );
+      string upperFileMDR = m_modelPath + fixFileCase( m_modelPath.c_str(), "upper.mdr" );
+      string headFileMDR  = m_modelPath + fixFileCase( m_modelPath.c_str(), "head.mdr"  );
+#endif
 
       if (     strncasecmp( m_modelBaseName.c_str(), "lower.", 6 ) == 0 
             || strncasecmp( m_modelBaseName.c_str(), "upper.", 6 ) == 0 
             || strncasecmp( m_modelBaseName.c_str(), "head.",  5 ) == 0 )
       {
+#ifdef MDR_LOAD
+         if ( (file_exists( lowerFile.c_str() ) || file_exists( lowerFileMDR.c_str() ))
+               && (file_exists( upperFile.c_str() ) || file_exists( upperFileMDR.c_str() ))
+               && (file_exists( headFile.c_str() ) || file_exists( headFileMDR.c_str() )) )
+#else
          if ( file_exists( lowerFile.c_str() )
                && file_exists( upperFile.c_str() )
                && file_exists( headFile.c_str() ) )
+#endif
          {
             log_debug( "have all files for %s\n", m_modelPath.c_str() );
 
@@ -235,7 +281,14 @@
          Md3FileDataT fd;
 
          fd.section = MS_Lower;
+#ifdef MDR_LOAD
+         if ( file_exists( lowerFileMDR.c_str() )
+         	fd.modelBaseName = "lower.mdr";
+         else
          fd.modelBaseName = "lower.md3";
+#else
+         fd.modelBaseName = "lower.md3";
+#endif
          fd.modelFile = lowerFile;
          fd.tag = "";
          fd.tagPoint = -1;
@@ -248,13 +301,27 @@
          fileList.push_back( fd );
 
          fd.section = MS_Upper;
+#ifdef MDR_LOAD
+         if ( file_exists( upperFileMDR.c_str() )
+         	fd.modelBaseName = "upper.mdr";
+         else
          fd.modelBaseName = "upper.md3";
+#else
+         fd.modelBaseName = "upper.md3";
+#endif
          fd.modelFile = upperFile;
          fd.tag = "tag_torso";
          fileList.push_back( fd );
 
          fd.section = MS_Head;
+#ifdef MDR_LOAD
+         if ( file_exists( headFileMDR.c_str() )
+         	fd.modelBaseName = "upper.mdr";
+         else
+         	fd.modelBaseName = "upper.md3";
+#else
          fd.modelBaseName = "head.md3";
+#endif
          fd.modelFile = headFile;
          fd.tag = "tag_head";
          fileList.push_back( fd );
@@ -316,6 +383,101 @@
          readString( pk3Name, sizeof( pk3Name ) );
          replaceBackslash( pk3Name );
 
+#ifdef MDR_LOAD
+         // MD3 header data.
+         int32_t flags = 0; // MD3 only
+         int32_t numFrames = 0;
+         int32_t numTags = 0;
+         int32_t numMeshes = 0; // MD3 only
+         int32_t numSkins = 0; // MD3 only
+         int32_t offsetFrames = 0;
+         int32_t offsetTags = 0;
+         int32_t offsetMeshes = 0; // MD3 only
+         int32_t offsetEnd = 0;
+
+         // MDR header data.
+         //int32_t numFrames = 0;
+         int32_t numBones = 0;
+         //int32_t offsetFrames = 0;
+         int32_t numLODs = 0;
+         int32_t offsetLODs = 0;
+         //int32_t numTags = 0;
+         //int32_t offsetTags = 0;
+         //int32_t offsetEnd = 0;
+
+         if ((*it).type == MT_MDR)
+         {
+            numFrames = readI4();
+            numBones = readI4();
+            offsetFrames = readI4();
+            numLODs = readI4();
+            offsetLODs = readI4();
+            numTags = readI4();
+            offsetTags = readI4();
+            offsetEnd = readI4();
+
+            log_debug( "Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+            log_debug( "Version: %d\n",     version );
+            log_debug( "PK3 Name: %s\n",    pk3Name );
+            log_debug( "Frames: %d\n",      numFrames );
+            log_debug( "Bones: %d\n",    numBones );
+            log_debug( "Offset Frames: %d\n",      offsetFrames );
+            log_debug( "LODs: %d\n",       numLODs );
+            log_debug( "Offset LODs: %d\n",      offsetLODs );
+            log_debug( "Tags: %d\n",        numTags );
+            log_debug( "Offset Tags: %d\n",  offsetTags );
+            log_debug( "Offset End: %d\n",        offsetEnd );
+            log_debug( "File Length: %d\n",       fileLength );
+
+            if ( magic[0] != 'R' && magic[1] != 'D' && magic[2] != 'M' && magic[3] != '5' )
+            {
+               log_debug( "Bad Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+               return Model::ERROR_BAD_MAGIC;
+            }
+
+            if ( version != MDR_VERSION )
+            {
+               return Model::ERROR_UNSUPPORTED_VERSION;
+            }
+         }
+         else // MT_MD3
+         {
+            flags = readI4();
+            numFrames = readI4();
+            numTags = readI4();
+            numMeshes = readI4();
+            numSkins = readI4();
+            offsetFrames = readI4();
+            offsetTags = readI4();
+            offsetMeshes = readI4();
+            offsetEnd = readI4();
+
+            log_debug( "Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+            log_debug( "Version: %d\n",     version );
+            log_debug( "PK3 Name: %s\n",    pk3Name );
+            log_debug( "Flags: %d\n",    flags );
+            log_debug( "Frames: %d\n",      numFrames );
+            log_debug( "Tags: %d\n",        numTags );
+            log_debug( "Meshes: %d\n",    numMeshes );
+            log_debug( "Skins: %d\n",       numSkins );
+            log_debug( "Offset Frames: %d\n",      offsetFrames );
+            log_debug( "Offset Tags: %d\n",  offsetTags );
+            log_debug( "Offset Meshes: %d\n",  offsetMeshes );
+            log_debug( "Offset End: %d\n",        offsetEnd );
+            log_debug( "File Length: %d\n",       fileLength );
+
+            if ( magic[0] != 'I' && magic[1] != 'D' && magic[2] != 'P' && magic[3] != '3' )
+            {
+               log_debug( "Bad Magic: %c%c%c%c\n", magic[0], magic[1], magic[2], magic[3] );
+               return Model::ERROR_BAD_MAGIC;
+            }
+
+            if ( version != MD3_VERSION )
+            {
+               return Model::ERROR_UNSUPPORTED_VERSION;
+            }
+         }
+#else
          int32_t flags = m_src->readI32();
          int32_t numFrames = m_src->readI32();
          int32_t numTags = m_src->readI32();
@@ -350,6 +512,7 @@
          {
             return Model::ERROR_UNSUPPORTED_VERSION;
          }
+#endif
 
          
          Md3PathT mpath;
@@ -364,6 +527,10 @@
          // frames
          // mm3d doesn't need this, but nice to have if you ever need to debug
 
+#ifdef MDR_LOAD
+         if ((*it).type == MT_MD3)
+         {
+#endif
 #if 0
          m_src->seek( offsetFrames );
          for ( int i = 0; i < numFrames; i++ )
@@ -398,6 +565,9 @@
             log_debug( "Frame %d name: %s\n", i, frameName );
          }
 #endif // 1
+#ifdef MDR_LOAD
+         }
+#endif
 
          if ( (*it).tag.size() > 0 )
          {
@@ -405,9 +575,16 @@
             log_debug( "tag point for %s is %d\n", (*it).tag.c_str(), (*it).tagPoint );
          }
 
+#ifdef MDR_LOAD
+         if ((*it).type == MT_MD3)
+         {
+#endif
          m_meshVecInfos = new MeshVectorInfoT*[numMeshes];
          setPoints( (*it).section, offsetTags, numTags, numFrames, (*it).tagPoint, -1 );
          setMeshes( (*it).section, offsetMeshes, numMeshes, (*it).tagPoint, -1 );
+#ifdef MDR_LOAD
+         }
+#endif
 
          (*it).meshVecInfos = m_meshVecInfos;
          (*it).src = m_src;
@@ -416,6 +593,11 @@
          (*it).offsetTags = offsetTags;
          (*it).numTags = numTags;
          (*it).numFrames = numFrames;
+#ifdef MDR_LOAD
+         (*it).numBones = numBones;
+         (*it).numLODs = numLODs;
+         (*it).offsetLODs = offsetLODs;
+#endif
       }
 
       if ( fileList.front().numFrames > 1 )
@@ -427,11 +609,19 @@
             {
                int animIndex = m_model->addAnimation( Model::ANIMMODE_FRAME, "AnimFrames" );
                m_model->setAnimFPS( Model::ANIMMODE_FRAME, animIndex, 15.0);
+#ifdef MD3_GENERAL // BUGFIX
+               m_model->setAnimFrameCount( Model::ANIMMODE_FRAME, animIndex, fileList.front().numFrames );
+#else
                m_model->setAnimFrameCount( Model::ANIMMODE_FRAME, 0, fileList.front().numFrames );
+#endif
             }
          }
       }
 
+#ifdef MDR_LOAD
+      if ((*it).type == MT_MD3)
+      {
+#endif
       for ( it = fileList.begin(); it != fileList.end(); it++ )
       {
          m_meshVecInfos = (*it).meshVecInfos;
@@ -445,6 +635,9 @@
             setMeshes( (*it).section, (*it).offsetMeshes, (*it).numMeshes, (*it).tagPoint, animIndex );
          }
       }
+#ifdef MDR_LOAD
+      }
+#endif
 
       // Set MD3_PATH
       size_t len = m_pathList.size();
@@ -497,6 +690,10 @@
          }
       }
 
+#ifdef MDR_LOAD
+      if ((*it).type == MT_MD3)
+      {
+#endif
       // Clean-up
       for ( it = fileList.begin(); it != fileList.end(); it++ )
       {
@@ -509,6 +706,9 @@
          (*it).src->close();
          (*it).src = NULL;
       }
+#ifdef MDR_LOAD
+      }
+#endif
 
       return Model::ERROR_NONE;
    }
@@ -531,6 +731,10 @@
    string animFile = m_modelPath + "animation.cfg";
    FILE * fp = fopen( animFile.c_str(), "r" );
    int animCount = 0;
+#ifdef MD3_GENERAL
+   std::vector<std::string> animNames;
+   int last_fcount = 0;
+#endif
 
    m_animStartFrame.clear();
    m_standFrame = 0;
@@ -563,10 +767,33 @@
             int fcount = 0;
             int loop   = 0;
             int fps    = 0;
+#ifdef MD3_GENERAL
+			char comment[128] = { 0 }; // May hold "//" or "//BOTH_x..."
+			char fname[128] = { 0 }; // May hold "BOTH_x..."
+
+			// Loads the following types
+			// "0 5 5 15"
+			// "0 5 5 15 //"
+			// "0 5 5 15 //BOTH_DEATH1"
+			// "0 5 5 15 // BOTH_DEATH1"
+			// "0 5 5 15 //         BOTH_DEATH1"
+			// "BOTH_DEATH1 0 5 5 15" (Elite Force Single Player style)
+			// If EF SP style, must check if valid animation name
+			//   (or metadata could be loaded as animation)
+
+            if ( sscanf( line, "%d %d %d %d %s %s",
+                   &first, &fcount, &loop, &fps, comment, fname ) >= 4
+			    || (sscanf( line, "%s %d %d %d %d",
+                      fname, &first, &fcount, &loop, &fps ) == 5
+				    && (strncasecmp(fname, "both_", 5) == 0 || strncasecmp(fname, "torso_", 6) == 0
+                      || strncasecmp(fname, "legs_", 5) == 0) ))
+#else
             if ( sscanf( line, "%d %d %d %d",
                      &first, &fcount, &loop, &fps ) == 4 )
+#endif
             {
                log_debug( "got anim frame details\n" );
+#ifndef MD3_GENERAL
                if ( animCount == 11 )
                {
                   m_standFrame = first;
@@ -575,8 +802,58 @@
                {
                   m_idleFrame = first;
                }
+#endif
 
+#ifdef MD3_GENERAL
+               // Check for animations that are played in reverse
+               if (fcount < 0)
+               {
+                  // FIXME: Make a note that it is reversed?
+                  fcount = abs(fcount);
+               }
+
+               char * name = NULL;
+
+               // Check if read name from file.
+               if (strlen(comment) > 7 || strlen(fname) > 5)
+               {
+                  // "//BOTH_x..."
+                  if (strlen(comment) > 7)
+                  {
+                     name = &comment[2];
+                  }
+                  // "BOTH_x..."
+                  else //if (strlen(fname) > 5)
+                  {
+                     name = fname;
+                  }
+
+                  for ( int i = 0; name[i]; i++ )
+                  {
+                     name[i] = tolower( name[i] );
+                  }
+               }
+               else
+               {
+                  // Failed to load name from file, use default.
+                  if ( animCount < MD3_ANIMATIONS )
+                  {
+                     // I won't change it, I promise
+                     name = (char *) s_animNames[ animCount ];
+                  }
+                  else
+                  {
+                     name = (char *) "Unknown";
+                  }
+               }
+               // Save name for offset fixing after animations are loaded.
+               animNames.push_back(name);
+
+               // It's a "both_" animation
+               if ( strncasecmp( name, "both_", 5 ) == 0 )
+#else
                if ( animCount < 6 )
+#endif
                {
                   if ( first + fcount > legsEnd )
                   {
@@ -591,8 +868,26 @@
                         bothEnd = std::max(bothEnd, first + fcount);
                      }
                   }
+#ifdef MD3_GENERAL
+                  // Check for single frame dead animation that use the last
+                  //   frame of the death animation
+                  if (animCount > 0 && strncasecmp(name, "both_dead", 9) == 0
+                     && strncasecmp(animNames[animCount-1].c_str(), "both_death", 10) == 0
+                     && fcount <= 1 )
+                  {
+                     if (m_animStartFrame[animCount-1] + last_fcount - 1 == first)
+                     {
+                        fcount = 0;
+                     }
+                  }
+#endif
                }
+#ifdef MD3_GENERAL
+               // It's a "torso_" animation
+               else if ( strncasecmp( name, "torso_", 6 ) == 0 )
+#else
                else if ( animCount < 13 )
+#endif
                {
                   if ( first + fcount > legsEnd )
                   {
@@ -607,8 +902,20 @@
                         torsoEnd = std::max(torsoEnd, first + fcount);
                      }
                   }
+#ifdef MD3_GENERAL
+                  // if name is "torso_stand"
+                  if ( strcasecmp(name, "torso_stand") == 0 )
+                  {
+                     m_standFrame = first;
+                  }
+#endif
                }
+#ifdef MD3_GENERAL
+               // It's a "legs_" animation
+               else if ( strncasecmp( name, "legs_", 5 ) == 0 )
+#else
                else
+#endif
                {
                   if ( legsStart == -1 )
                   {
@@ -620,12 +927,26 @@
                      legsStart = std::min(legsStart, first);
                      legsEnd = std::max(legsEnd, first + fcount);
                   }
+#ifdef MD3_GENERAL
+                  if ( strcasecmp(name, "legs_idle") == 0 )
+                  {
+                     m_idleFrame = first;
+                  }
+#endif
                }
+#ifdef MD3_GENERAL
+				else
+				{
+					// Unknown animation
+					log_debug( "unknown animation type-prefix '%s'\n", name );
+				}
+#endif
 
                m_animStartFrame.push_back( first );
 
                if ( create )
                {
+#ifndef MD3_GENERAL
                   const char * name = NULL;
                   if ( animCount < MD3_ANIMATIONS )
                   {
@@ -660,19 +981,75 @@
                         name = "Unknown";
                      }
                   }
+#endif
 
                   log_debug( "adding animation '%s'\n", name );
+#ifdef MD3_GENERAL // BUGFIX
+                  int animIndex = m_model->addAnimation( Model::ANIMMODE_FRAME, name );
+#else
                   int animIndex = m_model->addAnimation( Model::ANIMMODE_FRAME, s_animNames[ animCount ] );
+#endif
                   m_model->setAnimFPS( Model::ANIMMODE_FRAME, animIndex, (double) fps );
                   m_model->setAnimFrameCount( Model::ANIMMODE_FRAME, animIndex, fcount );
                }
 
                animCount++;
+#ifdef MD3_GENERAL
+               last_fcount = fcount;
+#endif
             }
             else
             {
                if ( create )
                {
+#ifdef MD3_GENERAL // TODO: Make sure this works!
+                  bool checkValue = false;
+                  char *name = NULL;
+                  std::string str;
+
+                  // save "name value"
+                  name = line;
+                  while( isspace(name[0]) )
+                  {
+                     name++;
+                  }
+                  int end = 0;
+                  while ( name[end] && name[end] != '\r' && name[end] != '\n' )
+                  {
+                     if (isspace(name[end]))
+                     {
+                        checkValue = true;
+                        break;
+                     }
+                     end++;
+                  }
+                  name[end] = '\0';
+                  end++;
+                  // TODO: Use MAX_DATAFIELD?
+                  str = "MD3_CFG_";
+                  str += name;
+
+                  if (checkValue)
+                  {
+                     char *value = &name[end];
+                     while( isspace(value[0]) )
+                     {
+                        value++;
+                     }
+                     end = 0;
+                     while ( value[end] && value[end] != '\r' && value[end] != '\n' )
+                     {
+                        end++;
+                     }
+                     value[end] = '\0';
+
+                     m_model->addMetaData( str.c_str(), value );
+                  }
+                  else
+                  {
+                    m_model->addMetaData( str.c_str(), "" );
+                  }
+#else
                   char * value = NULL;
                   if ( strncasecmp( line, "sex", 3 ) == 0 )
                   {
@@ -737,6 +1114,7 @@
                   {
                      log_warning( "Unknown meta data: %s", line );
                   }
+#endif
                }
             }
          }
@@ -744,6 +1122,19 @@
 
       fclose( fp );
 
+#ifdef MD3_GENERAL
+      if (m_standFrame == 0)
+      {
+         // Didn't find "torso_stand"
+         m_standFrame = torsoStart;
+      }
+      if (m_idleFrame == 0)
+      {
+         // Didn't find "legs_idle"
+         m_idleFrame = legsStart;
+      }
+#endif
+
       // Some animation files have the leg frames continuously numbered 
       // after the torso frames, others number the legs following the
       // "both" frames. Here we are adjusting the first case to make
@@ -752,8 +1143,16 @@
       if ( legsStart >= torsoEnd )
       {
          int animOffset = legsStart - torsoStart;
+#ifdef MD3_GENERAL
+         for ( size_t a = 0; a < m_animStartFrame.size(); ++a )
+#else
          for ( size_t a = 13; a < m_animStartFrame.size(); ++a )
+#endif
          {
+#ifdef MD3_GENERAL
+            if ( strncasecmp( animNames[a].c_str(), "legs_", 5 ) != 0 )
+               continue;
+#endif
             if ( m_animStartFrame[a] >= animOffset )
                m_animStartFrame[a] -= animOffset;
          }
@@ -1569,13 +1968,33 @@
          return true;
       }
    }
-   else if ( strcasecmp( tagName.c_str(), "tag_weapon" ) == 0 )
+   else if ( strcasecmp( tagName.c_str(), "tag_weapon" ) == 0
+#ifdef MD3_GENERAL // Support Team Arena tag point, not generalize :(
+      || strcasecmp( tagName.c_str(), "tag_flag" ) == 0
+#endif
+#ifdef TMNT // Tags used in yet-to-be release TMNT Arena ...
+      || strcasecmp( tagName.c_str(), "tag_hand_primary" ) == 0
+      || strcasecmp( tagName.c_str(), "tag_hand_secondary" ) == 0
+      || strcasecmp( tagName.c_str(), "tag_wp_away_primary" ) == 0
+      || strcasecmp( tagName.c_str(), "tag_wp_away_secondary" ) == 0
+#endif
+      )
    {
       if ( section == MS_Upper )
       {
          return true;
       }
    }
+#ifdef MD3_GENERAL
+   else
+   {
+      // Support unknown tags. Mods could add new tags.
+      //   Better to have unknown tag in all models then none.
+      // In Quake3 the programmer selects which section the tag is on,
+      //   so it should be harmless (Other then the larger file size in the models that don't use the tag...).
+      return true;
+   }
+#endif
 
    return false;
 }
@@ -1682,7 +2101,11 @@
       if ( haveUpper && haveLower )
       {
          if (  m_model->getPointByName( "tag_torso" )  < 0
+#ifdef TMNT // TMNT supports using tag_hand_primary as well as tag_weapon ...
+            || (m_model->getPointByName( "tag_weapon" ) < 0 || m_model->getPointByName( "tag_hand_primary" ) < 0)
+#else
             || m_model->getPointByName( "tag_weapon" ) < 0
+#endif
             || m_model->getPointByName( "tag_head" )   < 0 )
          {
             // missing required tags for player model
@@ -1713,8 +2136,25 @@
             }
             else
             {
+#ifdef MD3_GENERAL // BUGFIX: Automaticly saving as player was causing me some problems...
+		        char answer = msg_info_prompt( transll( QT_TRANSLATE_NOOP( "LowLevel", "This looks like a player model.\nDo you want to save all sections?")).c_str(), "Ync" );
+		        if ( answer == 'Y' )
+		        {
+		           model->addMetaData( "MD3_composite", "1" );
+		        }
+		        else if ( answer == 'N' )
+		        {
+		           model->addMetaData( "MD3_composite", "0" );
+		           saveAsPlayer = false;
+		        }
+		        else
+		        {
+		           return Model::ERROR_CANCEL;
+		        }
+#else
                // TODO: Eventually create a prompt instead of assuming "yes"
                log_debug( "model is implicitly a composite (no composite meta tag)\n" );
+#endif
             }
          }
          else
@@ -1757,12 +2197,28 @@
    }
 }
 
-Model::ModelErrorE Md3Filter::writeSectionFile( const char * filename, Md3Filter::MeshSectionE section, MeshList & meshes )
+Model::ModelErrorE Md3Filter::writeSectionFile( const char * filename, 
+#ifdef MDR_EXPORT
+   Md3Filter::MeshTypeE type,
+#endif
+   Md3Filter::MeshSectionE section, MeshList & meshes )
 {
    string modelPath = "";
    string modelBaseName = "";
    string modelFullName = "";
+#ifdef MDR_EXPORT
+   Model::AnimationModeE animationMode;
 
+   if (type == MT_MDR)
+   {
+      animationMode = Model::ANIMMODE_SKELETAL;
+   }
+   else // MT_MD3
+   {
+      animationMode = Model::ANIMMODE_FRAME;
+   }
+#endif
+
    log_debug( "writing section file %s\n", filename );
    switch ( section )
    {
@@ -1785,6 +2241,27 @@
 
    normalizePath( filename, modelFullName, modelPath, modelBaseName );
 
+#ifdef MDR_EXPORT
+   int8_t magic[4];
+   int32_t version = 0;
+   if (type == MT_MDR)
+   {
+      //MDR HEADER
+      magic[0] = 'R';
+      magic[1] = 'D';
+      magic[2] = 'M';
+      magic[3] = '5';
+      version = MDR_VERSION;
+   }
+   else
+   {
+      magic[0] = 'I';
+      magic[1] = 'D';
+      magic[2] = 'P';
+      magic[3] = '3';
+      version = MD3_VERSION;
+   }
+#else
    //MD3 HEADER
    int8_t magic[4];
    magic[0] = 'I';
@@ -1792,6 +2269,7 @@
    magic[2] = 'P';
    magic[3] = '3';
    int32_t version = MD3_VERSION;
+#endif
    char pk3Name[MAX_QPATH];
    std::string pk3Path = "";
    memset( pk3Name, 0, MAX_QPATH );
@@ -1814,14 +2292,22 @@
    int32_t flags = 0;
    int32_t numFrames = 0;
    //We are making all the anims be one anim.
+#ifdef MDR_EXPORT
+   unsigned animCount = m_model->getAnimCount( animationMode );
+#else
    unsigned animCount = m_model->getAnimCount( Model::ANIMMODE_FRAME );
+#endif
    for ( unsigned i = 0; i < animCount; i++ )
    {
       // Skip animations that don't belong in this section
       std::string name = getSafeName( i );
       if ( animInSection( name, section ) )
       {
+#ifdef MDR_EXPORT
+         numFrames += m_model->getAnimFrameCount( animationMode, i );
+#else
          numFrames += m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, i );
+#endif
       }
    }
 
@@ -1842,7 +2328,22 @@
    }
 
    unsigned pcount = m_model->getPointCount();
+#ifdef MD3_GENERAL
    int32_t numTags = (int32_t) pcount;
+   // If spliting model, count tags.
+   if (section == MS_Head || section == MS_Lower || section == MS_Upper)
+   {
+      numTags = 0;
+      for ( unsigned j = 0; j < pcount; j++ )
+      {
+         if ( tagInSection( m_model->getPointName( j ), section ) )
+         {
+            numTags++;
+         }
+      }
+   }
+#else
+   int32_t numTags = (int32_t) pcount;
    switch ( section )
    {
       case MS_Head:
@@ -1855,6 +2356,7 @@
       default:
          break;
    }
+#endif
 
    MeshList::iterator mlit;
 
@@ -1880,7 +2382,7 @@
       }
    }
 
-   int32_t numSkins = 0;
+   int32_t numSkins = 0; // MD3
    if ( numTags > MD3_MAX_TAGS )
    {
       log_error( "Number of tags(%d) is larger than %d\n.\n", numTags, MD3_MAX_TAGS );
@@ -1894,10 +2396,36 @@
       return Model::ERROR_FILTER_SPECIFIC;
    }
    // numSkins is usually zero for MD3 header, there can be skins for each mesh though later
+#ifdef MDR_EXPORT
+   int32_t numBones = 0; // MDR
+   int32_t offsetFrames = 0;
+   int32_t numLODs = 0; // MDR
+   int32_t offsetLODs = 0; // MDR
+   int32_t offsetTags = 0;
+   int32_t offsetMeshes = 0; // MD3
+   int32_t offsetEnd = 0;
+   if (type == MT_MDR)
+   {
+      numBones = m_model->getBoneJointCount(); // FIXME: Is this right?
+      offsetFrames = MDR_HEADER_SIZE;
+      numLODs = 1;
+      offsetLODs = offsetFrames + numFrames * (MDR_FRAME_SIZE + numBones * MDR_BONE_SIZE);
+      offsetTags = offsetFrames + numFrames * MDR_LOD_SIZE;
+      offsetEnd = offsetTags;
+   }
+   else
+   {
+      offsetFrames = MD3_HEADER_SIZE;
+      offsetTags = offsetFrames + numFrames * MD3_FRAME_SIZE;
+      offsetMeshes = offsetTags + numFrames * numTags * MD3_TAG_SIZE;
+      offsetEnd = offsetMeshes;
+   }
+#else
    int32_t offsetFrames = HEADER_SIZE;
    int32_t offsetTags = offsetFrames + numFrames * FRAME_SIZE;
    int32_t offsetMeshes = offsetTags + numFrames * numTags * TAG_SIZE;
    int32_t offsetEnd = offsetMeshes;
+#endif
 
    // MD3 limit tests
    if ( numTris > MD3_MAX_TRIANGLES )
@@ -1922,6 +2450,26 @@
       return err;
 
    // write file header
+#ifdef MDR_EXPORT
+   if (type == MT_MDR)
+   {
+      m_dst->write( magic[0] );
+      m_dst->write( magic[1] );
+      m_dst->write( magic[2] );
+      m_dst->write( magic[3] );
+      m_dst->write( version );
+      m_dst->writeS( pk3Name, MAX_QPATH ); // Why do I have MDR write this differently from MD3?...
+      m_dst->write( numFrames );
+      m_dst->write( numBones );
+      m_dst->write( offsetFrames );
+      m_dst->write( numLODs );
+      m_dst->write( offsetLODs );
+      m_dst->write( numTags );
+      m_dst->write( offsetTags );
+   }
+   else
+   {
+#endif
    m_dst->write( magic[0] );
    m_dst->write( magic[1] );
    m_dst->write( magic[2] );
@@ -1936,6 +2484,9 @@
    m_dst->write( offsetFrames );
    m_dst->write( offsetTags );
    m_dst->write( offsetMeshes );
+#ifdef MDR_EXPORT
+   }
+#endif
 
    uint32_t endPos = m_dst->offset();
    m_dst->write( offsetEnd );
@@ -1961,7 +2512,11 @@
       if ( animInSection( getSafeName( a ), section ) 
             || (section == MS_Head && a == 0) )
       {
+#ifdef MDR_EXPORT
+         unsigned aFrameCount = m_model->getAnimFrameCount( animationMode, a );
+#else
          unsigned aFrameCount = m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, a );
+#endif
          if ( (aFrameCount == 0 && animCount == 1 )
                || (section == MS_Head) )
          {
@@ -2029,10 +2584,41 @@
             char name[16] = "Misfit Model 3D"; // this is what other exporters do
             PORT_snprintf( name, sizeof(name), "%s%02d", animName.c_str(), t);
             m_dst->writeBytes( (uint8_t*) name, sizeof(name) );
+
+#ifdef MDR_EXPORT
+            if (type == MT_MDR)
+            {
+               // FIXME: Write MDR bone locations.
+               // float		matrix[3][4]; --to be written for each bone.
+               for (unsigned bone = 0; bone < numBones; bone++)
+               {
+                  //m_model->getBoneJointFinalMatrix(bone, m);
+                  //m_model->getBoneVector(bone, ..., ...);
+                  //bool getBoneVector( unsigned joint, double * vec, double * coord );
+                  // Write zeros for now... till this is fixed/finished.
+                  for (unsigned v = 0; v < 3; v++)
+                  {
+                     for (unsigned w = 0; w < 4; w++)
+                  	 {
+                  	    m_dst->write( (float)0 );
+                  	 }
+                  }
          }
       }
+#endif
    }
+      }
+   }
 
+#ifdef MDR_EXPORT
+   if (type == MT_MDR)
+   {
+      // Tags in MDR are done later.
+   }
+   else // MT_MD3
+   {
+#endif
+
    //TAGS
    log_debug( "writing tags at %d/%d\n", offsetTags, m_dst->offset() );
 
@@ -2100,9 +2686,45 @@
          }
       }
    }
+#ifdef MDR_EXPORT
+   }
+#endif
 
    vector<Model::Material *> & modelMaterials = getMaterialList( m_model );
 
+#ifdef MDR_EXPORT
+   if (type == MT_MDR)
+   {
+      // FIXME: Write MDR LODs
+      //log_debug( "writing LODs at %d/%d\n", offsetLODs, ftell( m_fpOut ) );
+#if 1
+      // Write LODs
+      for (unsigned i = 0; i < numLODs; i++)
+      {
+         //
+      }
+
+      // Write meshes
+      for (unsigned i = 0; i < numLODs; i++)
+      {
+         //
+      }
+#else // Below is what needs to be done.
+      //for each LOD
+         // write the number of surfaces (Meshes) (numSurfaces),
+         // offset of the first surfaces (Meshes) (offsetSurfaces),
+         // and the offset of the next LOD (offsetEnd)
+
+      // end LODs
+
+      // for each LOD
+         // Write surface (Mesh)
+      // end surfaces (Meshes)
+#endif
+   }
+   else // MT_MD3
+   {
+#endif
    // MESHES
    log_debug( "writing meshes at %d/%d\n", offsetMeshes, m_dst->offset() );
 
@@ -2345,7 +2967,41 @@
          }
       }
    }
+#ifdef MDR_EXPORT
+   }
 
+   if (type == MT_MDR)
+   {
+      //TAGS
+      log_debug( "writing tags at %d/%d\n", offsetTags, ftell( m_fpOut ) );
+
+      // Tags in MDR are simple (bone index and name)
+      for ( unsigned j = 0; j < pcount; j++ )
+      {
+         if ( tagInSection( m_model->getPointName( j ), section ) )
+         {
+            int32_t boneIndex = m_model->getPointBoneJoint(j);
+			m_dst->write(boneIndex);
+
+            char tName[32];
+            memset( tName, 0, sizeof( tName ) );
+            if ( PORT_snprintf( tName, sizeof( tName ), "%s", m_model->getPointName( j ) ) >= sizeof( tName ) )
+            {
+               fclose( m_fpOut );
+               log_error( "Point name is too large\n" );
+               m_model->setFilterSpecificError( "Point name is too large for MD3 export." );
+               return Model::ERROR_FILTER_SPECIFIC;
+            }
+            m_dst->writeS( tName, sizeof( tName ) );
+         }
+      }
+   }
+   else // MT_MD3
+   {
+      // Tags are done already.
+   }
+#endif
+
    offsetEnd = m_dst->offset();
    m_dst->seek( endPos );
    m_dst->write( offsetEnd );
@@ -2353,6 +3009,32 @@
    return Model::ERROR_NONE;
 }
 
+#ifdef MD3_GENERAL
+bool Md3Filter::AnimLoop(std::string name)
+{
+   for (int i = 0; s_animLoop[i] != NULL; i++)
+   {
+      if (strcmp(s_animLoop[i], name.c_str()) == 0)
+      {
+         return true;
+      }
+   }
+   return false;
+}
+
+bool Md3Filter::AnimSyncWarning(std::string name)
+{
+   for (int i = 0; s_animSyncWarning[i] != NULL; i++)
+   {
+      if (strcmp(s_animSyncWarning[i], name.c_str()) == 0)
+      {
+         return true;
+      }
+   }
+   return false;
+}
+#endif
+
 bool Md3Filter::writeAnimations()
 {
    string animFile = m_modelPath + "/animation.cfg";
@@ -2362,6 +3044,48 @@
    {
       log_debug( "writing animation.cfg\n" );
 
+#ifdef MD3_GENERAL
+      fprintf( fp, "// animation config file\r\n" );
+
+      bool hadKeyword = false;
+      char keyword[MAX_DATAFIELD], value[MAX_DATAFIELD];
+
+      for (unsigned int i = 0; i < m_model->getMetaDataCount(); i++)
+      {
+         if (!m_model->getMetaData(i, keyword, MAX_DATAFIELD, value, MAX_DATAFIELD))
+            continue;
+
+         if (strncasecmp(keyword, "MD3_CFG_", 8) == 0)
+         {
+            if (!hadKeyword)
+            {
+               hadKeyword = true;
+               fprintf( fp, "\r\n" );
+            }
+            if (strlen(value) > 0)
+               fprintf( fp, "%s %s\r\n", &keyword[8], value );
+            else
+               fprintf( fp, "%s\r\n", &keyword[8] );
+         }
+         // Support old keywords
+	 	 else if (strncasecmp(keyword, "MD3_sex", 7) == 0
+           || strncasecmp(keyword, "MD3_footsteps", 13) == 0
+           || strncasecmp(keyword, "MD3_headoffset", 14) == 0
+           || strncasecmp(keyword, "MD3_fixedtorso", 14) == 0
+           || strncasecmp(keyword, "MD3_fixedlegs", 13) == 0)
+         {
+            if (!hadKeyword)
+            {
+               hadKeyword = true;
+               fprintf( fp, "\r\n" );
+            }
+            if (strlen(value) > 0)
+               fprintf( fp, "%s %s\r\n", &keyword[4], value );
+            else
+               fprintf( fp, "%s\r\n", &keyword[4] );
+         }
+      }
+#else
       fprintf( fp, "// animation config file\r\n\r\n" );
 
       char value[30];
@@ -2385,6 +3109,7 @@
       {
          fprintf( fp, "fixedlegs %s\r\n", value );
       }
+#endif
 
       fprintf( fp, "\r\n" );
 
@@ -2392,6 +3117,19 @@
       fprintf( fp, "//    first   count   looping   fps\r\n\r\n" );
 
       char warning[] = " (MUST NOT CHANGE -- hand animation is synced to this)";
+#ifdef MD3_GENERAL
+      // FIXME: MDR uses skeleton
+      size_t animCount = m_model->getAnimCount( Model::ANIMMODE_FRAME );
+      for ( size_t anim = 0; anim < animCount; anim++ )
+      {
+         int animFrame = 0;
+         int count = 1;
+         int fps   = 15;
+         if (!getExportAnimData( (int)anim, animFrame, count, fps ))
+         {
+            continue;
+         }
+#else
       for ( int anim = 0; anim < MD3_ANIMATIONS; anim++ )
       {
          int animIndex = 0;
@@ -2399,15 +3137,32 @@
          int count = 1;
          int fps   = 15;
          getExportAnimData( anim, animIndex, animFrame, count, fps );
+#endif
 
          int loop = count; // loop by default
 
+#ifdef MD3_GENERAL
+         std::string name = getSafeName( anim );
+		 size_t len = name.length();
+         for ( size_t n = 0; n < len; n++ )
+         {
+            name[n] = std::toupper(name[n]);
+         }
+#endif
+
          // disable looping on non-looping anims
-         if ( count <= 1 || s_animLoop[anim] == 0 )
+         if ( count <= 1
+#ifdef MD3_GENERAL
+			|| !AnimLoop(name)
+#else
+            || s_animLoop[anim] == 0
+#endif
+            )
          {
             loop = 0;
          }
 
+#ifndef MD3_GENERAL
          char name[30];
          strcpy( name, s_animNames[anim] );
          size_t len = strlen( name );
@@ -2415,10 +3170,17 @@
          {
             name[n] = toupper( name[n] );
          }
+#endif
 
          fprintf( fp, "%d\t%d\t%d\t%d\t\t// %s%s\r\n", 
+#ifdef MD3_GENERAL
+               animFrame, count, loop, fps, name.c_str(),
+               (AnimSyncWarning(name) ? warning : "") );
+#else
                animFrame, count, loop, fps, name,
                (s_animSyncWarning[anim] ? warning : "") );
+#endif
+
       }
       fclose( fp );
       return true;
@@ -2458,21 +3220,57 @@
    return m;
 }
 
+#ifdef MD3_GENERAL
+bool Md3Filter::getExportAnimData( int modelAnim,
+      int & fileFrame, int & frameCount, int & fps )
+#else
 void Md3Filter::getExportAnimData( int fileAnim, int & modelAnim, 
       int & fileFrame, int & frameCount, int & fps )
+#endif
 {
    fileFrame  = 0;
    frameCount = 0;
 
    size_t animCount = m_model->getAnimCount( Model::ANIMMODE_FRAME );
+#ifdef MD3_GENERAL
+   MeshSectionE section = MS_None;
+   std::string animName = getSafeName( modelAnim );
 
+   if (strncasecmp(animName.c_str(), "torso_", 6) == 0)
+   {
+      section = MS_Upper;
+   }
+   else if (strncasecmp(animName.c_str(), "legs_", 5) == 0)
+   {
+      section = MS_Lower;
+   }
+
+   // If this is a "dead" animation and its after a "death" animation
+   //   and it has 0 frames, use the last frame of the death animation.
+   if (modelAnim > 0 && strncasecmp(animName.c_str(), "both_dead", 9) == 0
+      && strncasecmp(getSafeName( modelAnim - 1 ).c_str(), "both_death", 10) == 0
+      && m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, modelAnim ) == 0 )
+   {
+      if (getExportAnimData( modelAnim - 1, fileFrame, frameCount, fps ))
+      {
+         fileFrame += frameCount - 1;
+         frameCount = 1;
+         return true;
+      }
+   }
+#endif
+
    for ( size_t a = 0; a < animCount; a++ )
    {
       std::string name = getSafeName( a );
       if ( animInSection( name, MS_Upper )
             || animInSection( name, MS_Lower ) )
       {
+#ifdef MD3_GENERAL
+         if ( a == (size_t)modelAnim )
+#else
          if ( strcasecmp( s_animNames[ fileAnim ], name.c_str() ) == 0 )
+#endif
          {
             frameCount = m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, a );
             fps   = (int) m_model->getAnimFPS( Model::ANIMMODE_FRAME, a );
@@ -2482,17 +3280,41 @@
                fps = 15;
             }
 
+#ifdef MD3_GENERAL
+			if (section == MS_Lower)
+			{
+				// Must still count torso animations after this for fileFrame
+			}
+			else
+			{
+			   return true;
+			}
+#else
             return;
+#endif
          }
          else
+#ifdef MD3_GENERAL // All torso frames from go before leg frames, all legs go after tosro
+         if (section == MS_None || (section == MS_Lower && (a < (size_t)modelAnim || strncasecmp(name.c_str(), "legs_", 5) != 0))
+            || (section == MS_Upper && strncasecmp(name.c_str(), "legs_", 5) != 0))
+#endif
          {
             fileFrame += m_model->getAnimFrameCount( Model::ANIMMODE_FRAME, a );
          }
       }
    }
 
-   // if this is a "dead" animation and there isn't a "dead" animation, try the
-   // last frame of the "death" animation.
+#ifdef MD3_GENERAL
+   if (section == MS_Lower && frameCount)
+   {
+      // Finished adding up fileFrame for legs animations
+      return true;
+   }
+#endif
+
+#ifndef MD3_GENERAL
+   // If this is a "dead" animation and there isn't a "dead" animation, try the
+   //    last frame of the "death" animation.
    if ( fileAnim < 6 && (fileAnim % 2) == 1 )
    {
       fileAnim--;
@@ -2504,8 +3326,13 @@
          return;
       }
    }
+#endif
 
+#ifdef MD3_GENERAL
+   return false;
+#else
    modelAnim = -1;
+#endif
 }
 
 size_t Md3Filter::writeIdentity()
@@ -2672,7 +3499,12 @@
    log_debug( "isSupported( %s )\n", filename );
    unsigned len = strlen( filename );
 
+#ifdef MDR_GENERAL // Turtle Man: Is this load, export, or both?
+   if ( len >= 4 && ( strcasecmp( &filename[len-4], ".md3" ) == 0
+		|| strcasecmp( &filename[len-4], ".mdr" ) == 0 ) )
+#else
    if ( len >= 4 && strcasecmp( &filename[len-4], ".md3" ) == 0 )
+#endif
    {
       log_debug( "  true\n" );
       return true;
@@ -2688,6 +3520,9 @@
 {
    list<string> rval;
    rval.push_back( "*.md3" );
+#ifdef MDR_LOAD
+   rval.push_back( "*.mdr" );
+#endif
    return rval;
 }
 
@@ -2695,6 +3530,9 @@
 {
    list<string> rval;
    rval.push_back( "*.md3" );
+#ifdef MDR_EXPORT
+   rval.push_back( "*.mdr" );
+#endif
    return rval;
 }
 
